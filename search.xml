<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>GetBean 相关源码学习</title>
    <url>/2022/07/11/bean%20%E7%9B%B8%E5%85%B3%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="创建-bean-的过程"><a href="#创建-bean-的过程" class="headerlink" title="创建 bean 的过程"></a>创建 <code>bean</code> 的过程</h1><p>调用 <code>beanfactory</code> 中的 <code>getBean</code> 中的方法得到类的实体</p>
<p>其中方法中可以使用 <code>name</code> <code>requiredType</code> <code>args</code> 得到特定的类型</p>
<p>有如下签名</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object <span class="title function_">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line">&lt;T&gt; T <span class="title function_">getBean</span><span class="params">(String name, Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line">Object <span class="title function_">getBean</span><span class="params">(String name, Object... args)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line">&lt;T&gt; T <span class="title function_">getBean</span><span class="params">(Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line">&lt;T&gt; T <span class="title function_">getBean</span><span class="params">(Class&lt;T&gt; requiredType, Object... args)</span> <span class="keyword">throws</span> BeansException;</span><br></pre></td></tr></table></figure>

<p>进入 <code>getBean</code> 之后进入 <code>doGetBean</code> 方法统一处理所有的 <code>getBean</code> </p>
<p>在先去单例缓存中尝试取出 <code>bean</code> 如果没有 <code>bean</code> 通过 <code>singleton</code> 和 <code>prototype</code> 判断是创建单例还是原型</p>
<ol>
<li>单例</li>
</ol>
<p><code>AbstractBeanFactory.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">	    <span class="comment">// 从单例缓存中显式删除实例：它可能已经放在那里</span></span><br><span class="line">	    <span class="comment">// 急切地通过创建过程，以允许循环引用解析。</span></span><br><span class="line">	    <span class="comment">// 还要删除任何接收到对 bean 的临时引用的 bean。</span></span><br><span class="line">	    destroySingleton(beanName);</span><br><span class="line">	    <span class="keyword">throw</span> ex;</span><br><span class="line">	&#125;</span><br><span class="line">);</span><br><span class="line">beanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br></pre></td></tr></table></figure>

<p>调用 <code>createBean</code> 方法 创建 <code>bean</code> 同时注册进单例缓存中</p>
<p>调用 <code>getObjectForBeanInstance</code> 创建 <code>bean</code></p>
<ol start="2">
<li>原型</li>
</ol>
<p><code>AbstractBeanFactory.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">prototypeInstance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	beforePrototypeCreation(beanName);</span><br><span class="line">	prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">	afterPrototypeCreation(beanName);</span><br><span class="line">&#125;</span><br><span class="line">beanInstance = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br></pre></td></tr></table></figure>

<p>调用 <code>beforePrototypeCreation</code></p>
<p>调用 <code>createBean</code> 方法 创建 <code>bean</code></p>
<p>调用 <code>afterPrototypeCreation</code></p>
<p>调用 <code>getObjectForBeanInstance</code> 创建 <code>bean</code></p>
<p><small> <code>getObjectForBeanInstance</code> 这个方法 主要是获取给定 bean 实例的对象，bean 实例本身或其创建的对象（如果是 FactoryBean） </small></p>
<p>然后就是进入 <code>createBean</code> 方法之中执行 <code>doCreateBean</code> 方法加载创建类的细节</p>
<h1 id="在-doCreateBean-方法中"><a href="#在-doCreateBean-方法中" class="headerlink" title="在 doCreateBean 方法中"></a>在 <code>doCreateBean</code> 方法中</h1><ol>
<li><p>实例化 <code>bean</code> 调用 <code>createBeanInstance</code></p>
<ol>
<li>如果是通过 <code>@Bean</code> 加载 <code>bean</code> 的话，调用 <code>instantiateUsingFactoryMethod</code> 通过方法实例化</li>
<li>匹配类的构造器，通过构造器将类实例化</li>
</ol>
</li>
<li><p>填充 <code>bean</code> 中的字段</p>
<ol>
<li>填充字段的方案是由 <code>RootBeanDefinition</code> 这个包装类中的 <code>PropertyValues</code> 字段</li>
<li>主要是调用 <code>applyPropertyValues</code> 这个方法去填充字段 </li>
<li>如果使用注解的方式加载 <code>bean</code> 的话还会加载 <code>AutowiredAnnotationProcessor</code> 这样一个类，在填充的会使用其实现的一个 <code>postProcessProperties</code> 方式读取带有 <code>@Autowired</code> 的代码进行代码字段的注入</li>
</ol>
</li>
<li><p>初始化 <code>bean</code> </p>
<ol>
<li>调用 <code>Aware</code> 容器感知功能其执行的顺序是 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BeanNameAware</span><br><span class="line">BeanClassLoaderAware</span><br><span class="line">BeanFactoryAware</span><br></pre></td></tr></table></figure>
 通过这些方法可以在当前 <code>bean</code> 中后的例如: <code>bean name</code> <code>class loader</code> <code>bean factory</code> 等一些基础信息</li>
<li>调用 <code>BeanPostProcessor</code> 中的 <code>postProcessBeforeInitialization</code></li>
<li>调用用户自定义的 <code>init method</code></li>
<li>调用 <code>BeanPostProcessor</code> 中的 <code>postProcessAfterInitialization</code></li>
</ol>
</li>
<li><p>通过 <code>earlySingletonExposure</code> 解决依赖循环的问题</p>
</li>
<li><p>将该 <code>bean</code> 注册进 <code>disposable</code> 列表中</p>
</li>
</ol>
<p>返回类型</p>
<p>得到 <code>bean</code> 的整体流程结束</p>
]]></content>
      <categories>
        <category>spring</category>
        <category>ioc</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>ioc</tag>
      </tags>
  </entry>
  <entry>
    <title>读取 bean 相关源码学习</title>
    <url>/2022/07/14/%E8%AF%BB%E5%8F%96%20bean%20%E7%9B%B8%E5%85%B3%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="读取-bean-的过程"><a href="#读取-bean-的过程" class="headerlink" title="读取 bean 的过程"></a>读取 <code>bean</code> 的过程</h1><p>创建对象 <code>ClassPathXmlApplicationContext</code></p>
<p>通过 <code>refresh</code> 进行加载</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StartupStep</span> <span class="variable">contextRefresh</span> <span class="operator">=</span> <span class="built_in">this</span>.applicationStartup.start(<span class="string">&quot;spring.context.refresh&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 准备此上下文以进行刷新。</span></span><br><span class="line">prepareRefresh();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 告诉子类刷新内部 bean 工厂。</span></span><br><span class="line"><span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 准备 bean 工厂以在此上下文中使用。</span></span><br><span class="line">prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="comment">// 允许在上下文子类中对 bean 工厂进行后处理。</span></span><br><span class="line">	postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">	<span class="type">StartupStep</span> <span class="variable">beanPostProcess</span> <span class="operator">=</span> <span class="built_in">this</span>.applicationStartup.start(<span class="string">&quot;spring.context.beans.post-process&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 调用在上下文中注册为 bean 的工厂处理器。</span></span><br><span class="line">	invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 注册拦截 bean 创建的 bean 处理器。</span></span><br><span class="line">	registerBeanPostProcessors(beanFactory);</span><br><span class="line">	beanPostProcess.end();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 为此上下文初始化消息源。</span></span><br><span class="line">	initMessageSource();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 为此上下文初始化事件多播器。</span></span><br><span class="line">	initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化特定上下文子类中的其他特殊 bean。</span></span><br><span class="line">	onRefresh();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 检查侦听器 bean 并注册它们。</span></span><br><span class="line">	registerListeners();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 实例化所有剩余的（非惰性初始化）单例。</span></span><br><span class="line">	finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 最后一步：发布相应的事件。</span></span><br><span class="line">	finishRefresh();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">	<span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">		logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> + <span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 销毁已经创建的单例以避免悬空资源。</span></span><br><span class="line">	destroyBeans();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重置&#x27;活动&#x27;标志。</span></span><br><span class="line">	cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将异常传播给调用者。</span></span><br><span class="line">	<span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 重置 Spring 核心中的常见自省缓存，因为我们 </span></span><br><span class="line">    <span class="comment">// 可能不再需要单例 bean 的元数据...</span></span><br><span class="line">    resetCommonCaches();</span><br><span class="line">	contextRefresh.end();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个方法完成了 <code>spring</code> 三种加载 <code>bean</code> 的方法</p>
<ul>
<li>通过 <code>xml</code> 加载</li>
<li>通过 <code>java</code> 方法加载</li>
<li>通过 <code>spring</code> 自动加载</li>
</ul>
<h1 id="xml-读取方案"><a href="#xml-读取方案" class="headerlink" title="xml 读取方案"></a><code>xml</code> 读取方案</h1><p>方法流程 <code>obtainFreshBeanFactory</code> -&gt; <code>refreshBeanFactory</code> -&gt; <code>loadBeanDefinitions</code> -&gt; <code>doLoadBeanDefinitions</code> -&gt; <code>registerBeanDefinitions</code> -&gt; <code>doRegisterBeanDefinitions</code></p>
<p>然后在 <code>doRegisterBeanDefinitions</code> 在这个方法中使用解析 <code>xml</code> 的方法，在读取并拼装好 <code>bean</code> 的包装类 <code>BeanDefinition</code> 注册到全局唯一的 <code>beanFactory</code> 中</p>
<h1 id="java-方法加载"><a href="#java-方法加载" class="headerlink" title="java 方法加载"></a><code>java</code> 方法加载</h1><p>其主要是通过 <code>invokeBeanFactoryPostProcessors</code> 调用 <code>invokeBeanFactoryPostProcessors</code> 在这个方法内使用 <code>invokeBeanDefinitionRegistryPostProcessors</code> 方法通过 <code>BeanDefinitionRegistryPostProcessor</code> </p>
<p>所以现在的问题又变成其中的 <code>BeanDefinitionRegistryPostProcessor</code> 是如何出现的了和 <code>xml</code> 读取方式不同是的通过 <code>java</code> 代码打注解的方式加载 <code>bean</code> 必须使用 <code>AnnotationConfigApplicationContext</code> 这个加载类启动区别在于其多了一个 <code>scan</code> 或则 <code>register</code> 方法 ( 这取决你通过使用何种方式扫描 <code>bean</code></p>
<ul>
<li><code>scan</code>: 通过 <code>java</code> 包</li>
<li><code>register</code>: 通过配置类</li>
</ul>
<p>)</p>
<p>在 <code>register</code> 中的 <code>BeanDefinitionReaderUtils</code> 使用 <code>registerBeanDefinition</code> 去注册配置 <code>bean</code> 类的包装类</p>
<p>同时在创建 <code>AnnotationConfigApplicationContext</code> 类是，其会调用一些方法去注册固定的 <code>annotation post processon</code> 去完成 <code>@bean</code> 方法的注册</p>
<p>下面就是 <code>BeanDefinitionRegistryPostProcessor</code> 中到底做了什么</p>
<p>在 <code>BeanDefinitionRegistryPostProcessor</code> 中的一个实现子类 <code>ConfigurationClassPostProcessor</code> 是其解析和加载拥有 <code>@bean</code> 方法并且注册其的包装类</p>
<p>具体是怎么是做的呢</p>
<p>在 <code>processConfigBeanDefinitions</code> 这个方法中找出所有的 <code>@Configuration</code> 配置类，然后对每个配置类进项解析</p>
<p>在方法 <code>parse</code> 中去选择以何种方式调用 <code>processConfigurationClass</code> 在 <code>retrieveBeanMethodMetadata</code> 找出有 <code>@bean</code> 的方法，将其注册到 <code>ConfigurationClass</code> 中解析完成，<code>loadBeanDefinitions</code> 这个方法正常就是将 <code>bean</code> 包装注册。</p>
<h1 id="自动加载"><a href="#自动加载" class="headerlink" title="自动加载"></a>自动加载</h1><p>其加载方式和通过 <code>@bean</code> 加载代码的方式差不多你需要在类上打上 <code>@component</code> 这个注解以便让 <code>spring</code> 中 <code>@componentScan</code> 这个注解可以加载其</p>
<p>和上面的加载方式一样进入 <code>doProcessConfigurationClass</code> 方法只不过其调用其中的 <code>componentScanParser.parse</code> 方法去扫描所有的类看其实是否拥有 <code>@component</code> 注解如果有则将其包装注册 </p>
]]></content>
      <categories>
        <category>spring</category>
        <category>ioc</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>ioc</tag>
      </tags>
  </entry>
  <entry>
    <title>aop 相关源码学习</title>
    <url>/2022/07/17/aop%20%E7%9B%B8%E5%85%B3%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="aop-相关源码学习"><a href="#aop-相关源码学习" class="headerlink" title="aop 相关源码学习"></a><code>aop</code> 相关源码学习</h1><p>从使用 <code>bean</code> 的角度出发大概看一下源码</p>
<p><code>AbstractAutowireCapableBeanFactory</code> 中的初始化 <code>bean</code> 的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">wrappedBean</span> <span class="operator">=</span> bean;</span><br><span class="line"><span class="keyword">if</span> (mbd == <span class="literal">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">	wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>((mbd != <span class="literal">null</span> ? mbd.getResourceDescription() : <span class="literal">null</span>), beanName, <span class="string">&quot;Invocation of init method failed&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (mbd == <span class="literal">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">    wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中的 <code>applyBeanPostProcessorsAfterInitialization</code> 是 <code>aop</code> 加载的主要方法</p>
<p>在该方法中回去调用每个被注册在 <code>postProcessAfterInitialization</code> 而如果你是使用了 <code>aop</code> 则会注册一个 <code>AbstractAutoProxyCreator</code> 这一个类去装配 <code>aop</code></p>
<p>这个类重写的 <code>postProcessAfterInitialization</code> 如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(<span class="meta">@Nullable</span> Object bean, String beanName)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (bean != <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="type">Object</span> <span class="variable">cacheKey</span> <span class="operator">=</span> getCacheKey(bean.getClass(), beanName);</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.earlyProxyReferences.remove(cacheKey) != bean) &#123;</span><br><span class="line">			<span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中的 <code>wrapIfNecessary</code> 就是在必要时刻为 <code>bean</code> 创建代理</p>
<p>方法中有方法 <code>getAdvicesAndAdvisorsForBean</code> 以判断是否有必要为 <code>bean</code> 创建代理如果有需要则会调用 <code>createProxy</code> 方法创建代理</p>
<p><code>craeteProxy</code> 则对需要被代理 <code>bean</code> 经行包装成 <code>ProxyFactory</code> 类并且调用 <code>getProxy</code> 这个方法而其有两种代理的方式 <code>JDK</code> 和 <code>CGLIB</code> 两种代理方式</p>
<ol>
<li><code>JDK</code> 代理方式</li>
</ol>
<p>直接使用 <code>JDK</code> 的动态代理方式</p>
<p>主要是为了接口而是用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> Proxy.newProxyInstance(classLoader, <span class="built_in">this</span>.proxiedInterfaces, <span class="built_in">this</span>);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>CGLIB</code> 代理方式</li>
</ol>
<p>其实和 <code>JDK</code> 代理方式大同小异</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getProxy</span><span class="params">(<span class="meta">@Nullable</span> ClassLoader classLoader)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">		logger.trace(<span class="string">&quot;Creating CGLIB proxy: &quot;</span> + <span class="built_in">this</span>.advised.getTargetSource());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		Class&lt;?&gt; rootClass = <span class="built_in">this</span>.advised.getTargetClass();</span><br><span class="line">			Assert.state(rootClass != <span class="literal">null</span>, <span class="string">&quot;Target class must be available for creating a CGLIB proxy&quot;</span>);</span><br><span class="line"></span><br><span class="line">		Class&lt;?&gt; proxySuperClass = rootClass;</span><br><span class="line">		<span class="keyword">if</span> (rootClass.getName().contains(ClassUtils.CGLIB_CLASS_SEPARATOR)) &#123;</span><br><span class="line">			proxySuperClass = rootClass.getSuperclass();</span><br><span class="line">			Class&lt;?&gt;[] additionalInterfaces = rootClass.getInterfaces();</span><br><span class="line">			<span class="keyword">for</span> (Class&lt;?&gt; additionalInterface : additionalInterfaces) &#123;</span><br><span class="line">				<span class="built_in">this</span>.advised.addInterface(additionalInterface);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Validate the class, writing log messages as necessary.</span></span><br><span class="line">		validateClassIfNecessary(proxySuperClass, classLoader);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Configure CGLIB Enhancer...</span></span><br><span class="line">		<span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> createEnhancer();</span><br><span class="line">		<span class="keyword">if</span> (classLoader != <span class="literal">null</span>) &#123;</span><br><span class="line">			enhancer.setClassLoader(classLoader);</span><br><span class="line">			<span class="keyword">if</span> (classLoader <span class="keyword">instanceof</span> SmartClassLoader &amp;&amp;</span><br><span class="line">					((SmartClassLoader) classLoader).isClassReloadable(proxySuperClass)) &#123;</span><br><span class="line">				enhancer.setUseCache(<span class="literal">false</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		enhancer.setSuperclass(proxySuperClass);</span><br><span class="line">		enhancer.setInterfaces(AopProxyUtils.completeProxiedInterfaces(<span class="built_in">this</span>.advised));</span><br><span class="line">		enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);</span><br><span class="line">		enhancer.setStrategy(<span class="keyword">new</span> <span class="title class_">ClassLoaderAwareGeneratorStrategy</span>(classLoader));</span><br><span class="line"></span><br><span class="line">		Callback[] callbacks = getCallbacks(rootClass);</span><br><span class="line">		Class&lt;?&gt;[] types = <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[callbacks.length];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>; x &lt; types.length; x++) &#123;</span><br><span class="line">			types[x] = callbacks[x].getClass();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// fixedInterceptorMap only populated at this point, after getCallbacks call above</span></span><br><span class="line">		enhancer.setCallbackFilter(<span class="keyword">new</span> <span class="title class_">ProxyCallbackFilter</span>(</span><br><span class="line">				<span class="built_in">this</span>.advised.getConfigurationOnlyCopy(), <span class="built_in">this</span>.fixedInterceptorMap, <span class="built_in">this</span>.fixedInterceptorOffset));</span><br><span class="line">		enhancer.setCallbackTypes(types);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Generate the proxy class and create a proxy instance.</span></span><br><span class="line">		<span class="keyword">return</span> createProxyClassAndInstance(enhancer, callbacks);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (CodeGenerationException | IllegalArgumentException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AopConfigException</span>(<span class="string">&quot;Could not generate CGLIB subclass of &quot;</span> + <span class="built_in">this</span>.advised.getTargetClass() +</span><br><span class="line">				<span class="string">&quot;: Common causes of this problem include using a final class or a non-visible class&quot;</span>,</span><br><span class="line">				ex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">		<span class="comment">// TargetSource.getTarget() failed</span></span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AopConfigException</span>(<span class="string">&quot;Unexpected AOP exception&quot;</span>, ex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就是看一下 <code>CGLIB</code> 中是如何在代理中调用 <code>bean</code> 方法的其实通过一个名叫 <code>getCallbacks</code> 来得到有的代理方案</p>
<p>在 <code>callbacks</code> 这个数组中重要的是 <code>DynamicAdvisedInterceptor</code> 这个实现他会在调用方式时进行拦截 <code>CglibMethodInvocation</code> 创建这个类并且调用 <code>proceed</code> 方法通过责任链设计模式不断调用执行这个 <code>InterceptorAndDynamicMethodMatcher</code> 数组中的内容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.currentInterceptorIndex == <span class="built_in">this</span>.interceptorsAndDynamicMethodMatchers.size() - <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> invokeJoinpoint();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而这段代码则是确定了调用目标类的方法在中间使用</p>
<p>现在可以下一个定义就是 <code>aop</code> 是通过动态来实现这个事的</p>
<p>但是问题又来了 <code>interceptorsAndDynamicMethodMatchers</code> 是如何加载出来的</p>
<p>其是通过</p>
<p><code>AdvisorChainFactory</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AdvisorChainFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Determine a list of &#123;<span class="doctag">@link</span> org.aopalliance.intercept.MethodInterceptor&#125; objects</span></span><br><span class="line"><span class="comment">	 * for the given advisor chain configuration.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> config the AOP configuration in the form of an Advised object</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> method the proxied method</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> targetClass the target class (may be &#123;<span class="doctag">@code</span> null&#125; to indicate a proxy without</span></span><br><span class="line"><span class="comment">	 * target object, in which case the method&#x27;s declaring class is the next best option)</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> a List of MethodInterceptors (may also include InterceptorAndDynamicMethodMatchers)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	List&lt;Object&gt; <span class="title function_">getInterceptorsAndDynamicInterceptionAdvice</span><span class="params">(Advised config, Method method, <span class="meta">@Nullable</span> Class&lt;?&gt; targetClass)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>中的方法加载出来的</p>
<p>他会在里面加载所有的的 <code>advisor</code> 筛选出所有合适的加入数组进行使用</p>
<p>那么 <code>advisor</code> 又是如何被加入的呢</p>
<p>他是在之前的 <code>createProxy</code> 方法中执行如下方法链<br><code>buildAdvisors</code> -&gt; <code>getAdvicesAndAdvisorsForBean</code> -&gt; <code>findEligibleAdvisors</code></p>
<p>在这个方法中 <code>findCandidateAdvisors</code> 获得所有的 <code>bean</code> 如果其是 <code>advisor</code></p>
<p>然后在通过 <code>findAdvisorsThatCanApply</code> 去匹配 <code>advisor</code> 和目标类是否匹配</p>
]]></content>
      <categories>
        <category>spring</category>
        <category>aop</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>aop</tag>
      </tags>
  </entry>
  <entry>
    <title>spring webmvc 相关源码学习</title>
    <url>/2022/07/20/spring%20webmvc%20%E7%9B%B8%E5%85%B3%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="spring-webmvc-初始化过程"><a href="#spring-webmvc-初始化过程" class="headerlink" title="spring webmvc 初始化过程"></a><code>spring webmvc</code> 初始化过程</h1><h2 id="spring-webmvc-如何使用"><a href="#spring-webmvc-如何使用" class="headerlink" title="spring webmvc 如何使用"></a><code>spring webmvc</code> 如何使用</h2><p>首先，要导入</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">&#x27;org.springframework:spring-context:5.3.21&#x27;</span></span><br><span class="line">implementation <span class="string">&#x27;org.springframework:spring-webmvc:5.3.21&#x27;</span></span><br><span class="line">implementation <span class="string">&#x27;org.springframework:spring-web:5.3.21&#x27;</span></span><br><span class="line">compileOnly <span class="string">&#x27;javax.servlet:javax.servlet-api:4.0.0&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这样四个包</p>
<p>在<code>web.xml</code>中设置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextClass<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>org.springframework.web.context.support.AnnotationConfigWebApplicationContext<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>org.tolerate.mvc.AppConfig<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>0<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>同时新建类 <code>AppConfig</code> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.EnableWebMvc;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>spring</code> 的自动装配方案，并且开启 <code>WebMvc</code></p>
<p>同时新建类 <code>UserController</code> 打上 <code>RestController</code> 注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;你好&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后对 <code>tomcat</code> 经行启动配置 <code>spring webmvc</code> 就是启动了</p>
<h2 id="DispatcherServlet-源码学习"><a href="#DispatcherServlet-源码学习" class="headerlink" title="DispatcherServlet 源码学习"></a><code>DispatcherServlet</code> 源码学习</h2><p>首先第一点在 <code>tomcat</code> 的 <code>web.xml</code> 中如果我们给 <code>servlet</code> 设置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>0<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>则会在 <code>tomcat</code> 初始化时使用该 <code>servlet</code></p>
<p><code>DispatcherServlet</code> 其是 <code>HttpServletBean</code> 的子类而是 <code>HttpServlet</code> 的子类</p>
<p>在 <code>HttpServletBean</code> 实现了 <code>init</code> 方法</p>
<p>其方法链是 <code>init</code> -&gt; <code>initServletBean</code> -&gt; <code>initWebApplicationContext</code> -&gt; <code>configureAndRefreshWebApplicationContext</code> -&gt; <code>refresh</code> 直到 <code>refresh</code> 方法中去加载所有的 <code>bean</code> 这个在之前也是讲过的</p>
<p>但是其中有一个方法是当时没有注意到的 <code>finishBeanFactoryInitialization</code> 它会实例化剩余的所有的 <code>bean</code> 其中有一个类的初始化方法是加载映射 <code>mapping</code> 的</p>
<p>其类是 <code>RequestMappingHandlerMapping</code> 从 <code>afterPropertiesSet</code> -&gt; <code>initHandlerMethods</code> -&gt; <code>processCandidateBean</code> 到这个方法中去查看该类上是否有 <code>RestController</code> 注解如果有该注解</p>
<p>则会执行 <code>detectHandlerMethods</code> 方法在 <code>getMappingForMethod</code> 方法中选择出该类中所有的方法其拥有 <code>RequestMapping</code> 注解的方法并将其注册</p>
<p>至此 <code>spring webmvc</code> 初始化完成</p>
<h1 id="接口的请求"><a href="#接口的请求" class="headerlink" title="接口的请求"></a>接口的请求</h1><p>在 <code>FrameworkServlet</code> 中实现了所有的 <code>Servlet</code> 请求方案，同时这些请求方案都是在执行一个方法叫做 <code>processRequest</code> 来完成方法请求和映射在进行初始化之后则调用 <code>doService</code> 方法在去执行 <code>doDispatch</code></p>
<p>在 <code>doDispatch</code> 中会去 <code>handlerMappings</code> 中进行映射选择出合适的方式经行调用然后调用 <code>handle</code> 进行方法的调用同时将方法的结果放在方法 <code>processDispatchResult</code> 中处理查看放回的东西可以是 <code>ModelAndView</code>，也可以是要解析为 <code>ModelAndView</code> 的 <code>Exception</code></p>
]]></content>
      <categories>
        <category>spring</category>
        <category>webmvc</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>webmvc</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis 相关源码学习</title>
    <url>/2022/07/22/mybatis%20%E7%9B%B8%E5%85%B3%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="配置文件读取"><a href="#配置文件读取" class="headerlink" title="配置文件读取"></a>配置文件读取</h1><p><code>XMLConfigBuilder.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">parseConfiguration</span><span class="params">(XNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// issue #117 read properties first</span></span><br><span class="line">      propertiesElement(root.evalNode(<span class="string">&quot;properties&quot;</span>));</span><br><span class="line">      <span class="type">Properties</span> <span class="variable">settings</span> <span class="operator">=</span> settingsAsProperties(root.evalNode(<span class="string">&quot;settings&quot;</span>));</span><br><span class="line">      loadCustomVfs(settings);</span><br><span class="line">      loadCustomLogImpl(settings);</span><br><span class="line">      typeAliasesElement(root.evalNode(<span class="string">&quot;typeAliases&quot;</span>));</span><br><span class="line">      pluginElement(root.evalNode(<span class="string">&quot;plugins&quot;</span>));</span><br><span class="line">      objectFactoryElement(root.evalNode(<span class="string">&quot;objectFactory&quot;</span>));</span><br><span class="line">      objectWrapperFactoryElement(root.evalNode(<span class="string">&quot;objectWrapperFactory&quot;</span>));</span><br><span class="line">      reflectorFactoryElement(root.evalNode(<span class="string">&quot;reflectorFactory&quot;</span>));</span><br><span class="line">      settingsElement(settings);</span><br><span class="line">      <span class="comment">// read it after objectFactory and objectWrapperFactory issue #631</span></span><br><span class="line">      environmentsElement(root.evalNode(<span class="string">&quot;environments&quot;</span>));</span><br><span class="line">      databaseIdProviderElement(root.evalNode(<span class="string">&quot;databaseIdProvider&quot;</span>));</span><br><span class="line">      typeHandlerElement(root.evalNode(<span class="string">&quot;typeHandlers&quot;</span>));</span><br><span class="line">      mapperElement(root.evalNode(<span class="string">&quot;mappers&quot;</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BuilderException</span>(<span class="string">&quot;Error parsing SQL Mapper Configuration. Cause: &quot;</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>在这个方法中的 <code>environmentsElement</code> 方法是去加载数据库连接等关键信息</p>
<p>同时 <code>mapperElement</code> 方法内部则是通过一个循环加载 <code>&lt;mappers&gt;</code> 中所有的 <code>&lt;mapper&gt;</code> 中的内容</p>
<p><code>XMLMapperBuilder.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">configurationElement</span><span class="params">(XNode context)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">namespace</span> <span class="operator">=</span> context.getStringAttribute(<span class="string">&quot;namespace&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> (namespace == <span class="literal">null</span> || namespace.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BuilderException</span>(<span class="string">&quot;Mapper&#x27;s namespace cannot be empty&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      builderAssistant.setCurrentNamespace(namespace);</span><br><span class="line">      cacheRefElement(context.evalNode(<span class="string">&quot;cache-ref&quot;</span>));</span><br><span class="line">      cacheElement(context.evalNode(<span class="string">&quot;cache&quot;</span>));</span><br><span class="line">      parameterMapElement(context.evalNodes(<span class="string">&quot;/mapper/parameterMap&quot;</span>));</span><br><span class="line">      resultMapElements(context.evalNodes(<span class="string">&quot;/mapper/resultMap&quot;</span>));</span><br><span class="line">      sqlElement(context.evalNodes(<span class="string">&quot;/mapper/sql&quot;</span>));</span><br><span class="line">      buildStatementFromContext(context.evalNodes(<span class="string">&quot;select|insert|update|delete&quot;</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BuilderException</span>(<span class="string">&quot;Error parsing Mapper XML. The XML location is &#x27;&quot;</span> + resource + <span class="string">&quot;&#x27;. Cause: &quot;</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个方法中回去调用 <code>buildStatementFromContext</code> 方法去加载 <code>&lt;mapper&gt;</code> 所有的方法并且将配置好的方法存入 <code>MapperBuilderAssistant</code> 类中的 <code>mappedStatements</code> 中</p>
<p>在进行过这个方法之后我们就有了一个基础的 <code>mapper</code> 存在于 <code>mappedStatements</code> 现在就是执行</p>
<p><code>XMLMapperBuilder.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parse</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!configuration.isResourceLoaded(resource)) &#123;</span><br><span class="line">      configurationElement(parser.evalNode(<span class="string">&quot;/mapper&quot;</span>));</span><br><span class="line">      configuration.addLoadedResource(resource);</span><br><span class="line">      bindMapperForNamespace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    parsePendingResultMaps();</span><br><span class="line">    parsePendingCacheRefs();</span><br><span class="line">    parsePendingStatements();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面一个方法 <code>bindMapperForNamespace</code> 去将 <code>mapper</code> 注册进 <code>knownMappers</code> 这个 <code>map</code> 进行使用</p>
<p>到此基础的 <code>mapper</code> 加载完成</p>
<h1 id="mapper-方法获取"><a href="#mapper-方法获取" class="headerlink" title="mapper 方法获取"></a><code>mapper</code> 方法获取</h1><p>下面就是先创建一个 <code>sqlSession</code> 去连接数据库</p>
<p>然后调用 <code>getMapper</code> 方法获得被代理的类</p>
<p>如下 </p>
<p><code>MapperRegistry.java</code> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getMapper</span><span class="params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory&lt;T&gt;) knownMappers.get(type);</span><br><span class="line">    <span class="keyword">if</span> (mapperProxyFactory == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BindingException</span>(<span class="string">&quot;Type &quot;</span> + type + <span class="string">&quot; is not known to the MapperRegistry.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> mapperProxyFactory.newInstance(sqlSession);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BindingException</span>(<span class="string">&quot;Error getting mapper instance. Cause: &quot;</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实本质就是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> T <span class="title function_">newInstance</span><span class="params">(MapperProxy&lt;T&gt; mapperProxy)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; mapperInterface &#125;, mapperProxy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="方法的调用"><a href="#方法的调用" class="headerlink" title="方法的调用"></a>方法的调用</h1><p>继续看方法是如何被代理的</p>
<p>通过类 <code>MapperProxy</code> 其继承了 <code>InvocationHandler</code> 其中 <code>invoke</code> 实现如下 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(<span class="built_in">this</span>, args);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cachedInvoker(method).invoke(proxy, method, args, sqlSession);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在方法 <code>cachedInvoker</code> 中会创建 <code>PlainMethodInvoker</code> 类实现方法的代理然后在其中调用方法 <code>execute</code> 去确实代理方法</p>
<p>其主要是使用了 <code>DefaultSqlSession</code> 实现的各中方法如: <code>selectOne</code> <code>selectCursor</code> <code>selectList</code> 并将值返回</p>
]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>spring boot web 相关源码学习</title>
    <url>/2022/08/04/spring%20boot%20web%20%E7%9B%B8%E5%85%B3%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="spring-boot-web-相关源码学习"><a href="#spring-boot-web-相关源码学习" class="headerlink" title="spring boot web 相关源码学习"></a><code>spring boot web</code> 相关源码学习</h1><h2 id="spring-boot-自动加载机制"><a href="#spring-boot-自动加载机制" class="headerlink" title="spring boot 自动加载机制"></a><code>spring boot</code> 自动加载机制</h2><p>通过上面的论述, 先来看一下 <code>spring boot</code> 项目启动类上的注解 <code>SpringBootApplication</code> 是怎么长的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span></span><br><span class="line"><span class="meta">		@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@AliasFor(annotation = EnableAutoConfiguration.class)</span></span><br><span class="line">	Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@AliasFor(annotation = EnableAutoConfiguration.class)</span></span><br><span class="line">	String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@AliasFor(annotation = ComponentScan.class, attribute = &quot;basePackages&quot;)</span></span><br><span class="line">	String[] scanBasePackages() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@AliasFor(annotation = ComponentScan.class, attribute = &quot;basePackageClasses&quot;)</span></span><br><span class="line">	Class&lt;?&gt;[] scanBasePackageClasses() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@AliasFor(annotation = ComponentScan.class, attribute = &quot;nameGenerator&quot;)</span></span><br><span class="line">	Class&lt;? <span class="keyword">extends</span> <span class="title class_">BeanNameGenerator</span>&gt; nameGenerator() <span class="keyword">default</span> BeanNameGenerator.class;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@AliasFor(annotation = Configuration.class)</span></span><br><span class="line">	<span class="type">boolean</span> <span class="title function_">proxyBeanMethods</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中的关键节点是 <code>EnableAutoConfiguration</code> 这个注解, 再来看一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import(AutoConfigurationImportSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">ENABLED_OVERRIDE_PROPERTY</span> <span class="operator">=</span> <span class="string">&quot;spring.boot.enableautoconfiguration&quot;</span>;</span><br><span class="line"></span><br><span class="line">	Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">	String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其重要的导入类 <code>AutoConfigurationImportSelector</code> </p>
<p>这个类会在方法 <code>processImports</code> 调用 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.deferredImportSelectorHandler.handle(configClass, (DeferredImportSelector) selector);</span><br></pre></td></tr></table></figure>

<p>这样一段话去处理 <code>AutoConfigurationImportSelector</code> 再发方法中将其注册进 <code>deferredImportSelectors</code> 之中</p>
<p>然后就是在方法 <code>parse</code> 方法中最后会调用的方法 <code>DeferredImportSelectorHandler.process</code> 方法如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">()</span> &#123;</span><br><span class="line">	List&lt;DeferredImportSelectorHolder&gt; deferredImports = <span class="built_in">this</span>.deferredImportSelectors;</span><br><span class="line">	<span class="built_in">this</span>.deferredImportSelectors = <span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (deferredImports != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="type">DeferredImportSelectorGroupingHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeferredImportSelectorGroupingHandler</span>();</span><br><span class="line">			deferredImports.sort(DEFERRED_IMPORT_COMPARATOR);</span><br><span class="line">			deferredImports.forEach(handler::register);</span><br><span class="line">			handler.processGroupImports();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.deferredImportSelectors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其会创建一个 <code>DeferredImportSelectorGroupingHandler</code> 的对象, 然后将 <code>handler</code> 通过 <code>register</code> 进行注册, 之后执行 <code>processGroupImports</code> 方法如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processGroupImports</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> (DeferredImportSelectorGrouping grouping : <span class="built_in">this</span>.groupings.values()) &#123;</span><br><span class="line">		Predicate&lt;String&gt; exclusionFilter = grouping.getCandidateFilter();</span><br><span class="line">		grouping.getImports().forEach(entry -&gt; &#123;</span><br><span class="line">			<span class="type">ConfigurationClass</span> <span class="variable">configurationClass</span> <span class="operator">=</span> <span class="built_in">this</span>.configurationClasses.get(entry.getMetadata());</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				processImports(configurationClass, asSourceClass(configurationClass, exclusionFilter),</span><br><span class="line">				Collections.singleton(asSourceClass(entry.getImportClassName(), exclusionFilter)),</span><br><span class="line">				exclusionFilter, <span class="literal">false</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">				<span class="keyword">throw</span> ex;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(</span><br><span class="line">					<span class="string">&quot;Failed to process import candidates for configuration class [&quot;</span> +</span><br><span class="line">						configurationClass.getMetadata().getClassName() + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>他会遍历每个被中注册的 <code>groupings</code> 并且调用其 <code>getImports</code> 在这个方法中会从 <code>META-INF/spring.factories</code> 去自动加载类并且进行筛选<br>之后通过函数表达式将所有的类当成 <code>ConfigurationClass</code> 通过 <code>processImports</code> 进行加载</p>
<p>到这里 <code>spring boot</code> 的自动加载机制算是告一段落</p>
<h2 id="spring-boot-web-启动"><a href="#spring-boot-web-启动" class="headerlink" title="spring boot web 启动"></a><code>spring boot web</code> 启动</h2><p>先来看 <code>SpringApplication.run</code> 方法</p>
<p>在这个方法中他回去加载环境输出 <code>banner</code> 和创建 <code>context</code> 该 <code>context</code> 的类型为 <code>AnnotationConfigServletWebServerApplicationContext</code></p>
<p>在创建了 <code>context</code> 会去使用 <code>refreshContext</code> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">refreshContext</span><span class="params">(ConfigurableApplicationContext context)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">this</span>.registerShutdownHook) &#123;</span><br><span class="line">		shutdownHook.registerApplicationContext(context);</span><br><span class="line">	&#125;</span><br><span class="line">	refresh(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个方法中调用了 <code>refresh</code> 方法去加载注册所有的 <code>bean</code> 同时在 <code>refresh</code> 中的 <code>onRefresh</code> 也是被重写过的</p>
<p>其去加载服务器方法如下 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">createWebServer</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">WebServer</span> <span class="variable">webServer</span> <span class="operator">=</span> <span class="built_in">this</span>.webServer;</span><br><span class="line">	<span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> getServletContext();</span><br><span class="line">	<span class="keyword">if</span> (webServer == <span class="literal">null</span> &amp;&amp; servletContext == <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="type">StartupStep</span> <span class="variable">createWebServer</span> <span class="operator">=</span> <span class="built_in">this</span>.getApplicationStartup().start(<span class="string">&quot;spring.boot.webserver.create&quot;</span>);</span><br><span class="line">		<span class="type">ServletWebServerFactory</span> <span class="variable">factory</span> <span class="operator">=</span> getWebServerFactory();</span><br><span class="line">		createWebServer.tag(<span class="string">&quot;factory&quot;</span>, factory.getClass().toString());</span><br><span class="line">		<span class="built_in">this</span>.webServer = factory.getWebServer(getSelfInitializer());</span><br><span class="line">		createWebServer.end();</span><br><span class="line">		getBeanFactory().registerSingleton(<span class="string">&quot;webServerGracefulShutdown&quot;</span>,</span><br><span class="line">				<span class="keyword">new</span> <span class="title class_">WebServerGracefulShutdownLifecycle</span>(<span class="built_in">this</span>.webServer));</span><br><span class="line">		getBeanFactory().registerSingleton(<span class="string">&quot;webServerStartStop&quot;</span>,</span><br><span class="line">				<span class="keyword">new</span> <span class="title class_">WebServerStartStopLifecycle</span>(<span class="built_in">this</span>, <span class="built_in">this</span>.webServer));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (servletContext != <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			getSelfInitializer().onStartup(servletContext);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (ServletException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ApplicationContextException</span>(<span class="string">&quot;Cannot initialize servlet context&quot;</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	initPropertySources();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面举例常见的 <code>tomcat</code> 的加载举例</p>
<p>首先该方法通过 <code>getWebServerFactory</code> 方法获得一个被当作 <code>bean</code> 加载的 <code>web</code> 服务器</p>
<p>然后再通过 <code>factory.getWebServer</code> 方法得到 <code>web</code> 服务器的实例并进行注册其的关机方法</p>
<p>继续看内嵌的 <code>tomcat</code> 是如何启动加载的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> WebServer <span class="title function_">getWebServer</span><span class="params">(ServletContextInitializer... initializers)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">this</span>.disableMBeanRegistry) &#123;</span><br><span class="line">		Registry.disableRegistry();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">Tomcat</span> <span class="variable">tomcat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tomcat</span>();</span><br><span class="line">	<span class="type">File</span> <span class="variable">baseDir</span> <span class="operator">=</span> (<span class="built_in">this</span>.baseDirectory != <span class="literal">null</span>) ? <span class="built_in">this</span>.baseDirectory : createTempDir(<span class="string">&quot;tomcat&quot;</span>);</span><br><span class="line">	tomcat.setBaseDir(baseDir.getAbsolutePath());</span><br><span class="line">	<span class="keyword">for</span> (LifecycleListener listener : <span class="built_in">this</span>.serverLifecycleListeners) &#123;</span><br><span class="line">		tomcat.getServer().addLifecycleListener(listener);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">Connector</span> <span class="variable">connector</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Connector</span>(<span class="built_in">this</span>.protocol);</span><br><span class="line">	connector.setThrowOnFailure(<span class="literal">true</span>);</span><br><span class="line">	tomcat.getService().addConnector(connector);</span><br><span class="line">	customizeConnector(connector);</span><br><span class="line">	tomcat.setConnector(connector);</span><br><span class="line">	tomcat.getHost().setAutoDeploy(<span class="literal">false</span>);</span><br><span class="line">	configureEngine(tomcat.getEngine());</span><br><span class="line">	<span class="keyword">for</span> (Connector additionalConnector : <span class="built_in">this</span>.additionalTomcatConnectors) &#123;</span><br><span class="line">		tomcat.getService().addConnector(additionalConnector);</span><br><span class="line">	&#125;</span><br><span class="line">	prepareContext(tomcat.getHost(), initializers);</span><br><span class="line">	<span class="keyword">return</span> getTomcatWebServer(tomcat);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个方法中其创建了一个 <code>tomcat</code> 实例, 同时设置其的 <code>context</code> 还会调用方法 <code>initializers</code> </p>
<p>其会在 <code>getSelfInitializer</code> 方法中加载</p>
<p>同时在 <code>context</code> 方法中还会设置一个实现 <code>ServletContainerInitializer</code> 的类 <code>TomcatStarter</code> 它实现了 <code>onStartup</code> 这样一个方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStartup</span><span class="params">(Set&lt;Class&lt;?&gt;&gt; classes, ServletContext servletContext)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (ServletContextInitializer initializer : <span class="built_in">this</span>.initializers) &#123;</span><br><span class="line">			initializer.onStartup(servletContext);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">		<span class="built_in">this</span>.startUpException = ex;</span><br><span class="line">		<span class="comment">// Prevent Tomcat from logging and re-throwing when we know we can</span></span><br><span class="line">		<span class="comment">// deal with it in the main thread, but log for information here.</span></span><br><span class="line">		<span class="keyword">if</span> (logger.isErrorEnabled()) &#123;</span><br><span class="line">			logger.error(<span class="string">&quot;Error starting Tomcat context. Exception: &quot;</span> + ex.getClass().getName() + <span class="string">&quot;. Message: &quot;</span></span><br><span class="line">					+ ex.getMessage());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这方法中它会在启动的时候加载所有的 <code>initizlizers</code> 如关键的 <code>dispatchServlet</code> </p>
<p><code>tomcat</code> 启动到这就差不多了</p>
<p>由于加载了 <code>dispatchServlet</code> 下面的问题又回到了 <code>spring mvc</code> 中了</p>
]]></content>
      <categories>
        <category>spring boot</category>
        <category>web</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>Import 相关学习</title>
    <url>/2022/08/04/@Import%20%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="Import-相关学习"><a href="#Import-相关学习" class="headerlink" title="@Import 相关学习"></a><code>@Import</code> 相关学习</h1><!-- 在论述 `spring boot web` 的问题之前我们先要叙述一个之前没有论述的注解 `@Import` 加载方式 -->

<p><code>@Import</code> 的使用</p>
<p><code>App.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Import(&#123;UserController.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(BeanConfig1.class);</span><br><span class="line">        context.getBean(UserController.class).func();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>UserContorller.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由此可见这个注解的作用就是直接导入当前想要加载的类，但类不在扫描包的范围内</p>
<p>现在再看看这个注解中的 <code>value</code> 是如何加载进入 <code>beanFactory</code> 中的</p>
<p>先回到熟悉的 <code>ConfigurationClassParser</code> 这个类的解析方案中其中方法 <code>processImports</code> 则是用来加载资源类上的 <code>@Import</code> 注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processImports</span><span class="params">(ConfigurationClass configClass, SourceClass currentSourceClass,</span></span><br><span class="line"><span class="params">		Collection&lt;SourceClass&gt; importCandidates, Predicate&lt;String&gt; exclusionFilter,</span></span><br><span class="line"><span class="params">		<span class="type">boolean</span> checkForCircularImports)</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (importCandidates.isEmpty()) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (checkForCircularImports &amp;&amp; isChainedImportOnStack(configClass)) &#123;</span><br><span class="line">		<span class="built_in">this</span>.problemReporter.error(<span class="keyword">new</span> <span class="title class_">CircularImportProblem</span>(configClass, <span class="built_in">this</span>.importStack));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.importStack.push(configClass);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">		    <span class="keyword">for</span> (SourceClass candidate : importCandidates) &#123;</span><br><span class="line">			    <span class="keyword">if</span> (candidate.isAssignable(ImportSelector.class)) &#123;</span><br><span class="line">                    <span class="comment">// Candidate class is an ImportSelector -&gt; delegate to it to determine imports</span></span><br><span class="line">                    Class&lt;?&gt; candidateClass = candidate.loadClass();</span><br><span class="line">                    <span class="type">ImportSelector</span> <span class="variable">selector</span> <span class="operator">=</span> ParserStrategyUtils.instantiateClass(candidateClass, ImportSelector.class,</span><br><span class="line">                        <span class="built_in">this</span>.environment, <span class="built_in">this</span>.resourceLoader, <span class="built_in">this</span>.registry);</span><br><span class="line">                    Predicate&lt;String&gt; selectorFilter = selector.getExclusionFilter();</span><br><span class="line">                    <span class="keyword">if</span> (selectorFilter != <span class="literal">null</span>) &#123;</span><br><span class="line">                        exclusionFilter = exclusionFilter.or(selectorFilter);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (selector <span class="keyword">instanceof</span> DeferredImportSelector) &#123;</span><br><span class="line">                        <span class="built_in">this</span>.deferredImportSelectorHandler.handle(configClass, (DeferredImportSelector) selector);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        String[] importClassNames = selector.selectImports(currentSourceClass.getMetadata());</span><br><span class="line">                        Collection&lt;SourceClass&gt; importSourceClasses = asSourceClasses(importClassNames, exclusionFilter);</span><br><span class="line">                        processImports(configClass, currentSourceClass, importSourceClasses, exclusionFilter, <span class="literal">false</span>);</span><br><span class="line">		    	    &#125;</span><br><span class="line">			    &#125;</span><br><span class="line">			    <span class="keyword">else</span> <span class="keyword">if</span> (candidate.isAssignable(ImportBeanDefinitionRegistrar.class)) &#123;</span><br><span class="line">			        <span class="comment">// Candidate class is an ImportBeanDefinitionRegistrar -&gt;</span></span><br><span class="line">		    	    <span class="comment">// delegate to it to register additional bean definitions</span></span><br><span class="line">			        Class&lt;?&gt; candidateClass = candidate.loadClass();</span><br><span class="line">			        <span class="type">ImportBeanDefinitionRegistrar</span> <span class="variable">registrar</span> <span class="operator">=</span></span><br><span class="line">				    ParserStrategyUtils.instantiateClass(candidateClass, ImportBeanDefinitionRegistrar.class,</span><br><span class="line">					    <span class="built_in">this</span>.environment, <span class="built_in">this</span>.resourceLoader, <span class="built_in">this</span>.registry);</span><br><span class="line">			        configClass.addImportBeanDefinitionRegistrar(registrar, currentSourceClass.getMetadata());</span><br><span class="line">			    &#125;</span><br><span class="line">			    <span class="keyword">else</span> &#123;</span><br><span class="line">			        <span class="comment">// Candidate class not an ImportSelector or ImportBeanDefinitionRegistrar -&gt;</span></span><br><span class="line">			        <span class="comment">// process it as an @Configuration class</span></span><br><span class="line">			        <span class="built_in">this</span>.importStack.registerImport(</span><br><span class="line">				        currentSourceClass.getMetadata(), candidate.getMetadata().getClassName());</span><br><span class="line">			        processConfigurationClass(candidate.asConfigClass(configClass), exclusionFilter);</span><br><span class="line">			    &#125;</span><br><span class="line">		    &#125;</span><br><span class="line">    	&#125;</span><br><span class="line">	    <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">	       <span class="keyword">throw</span> ex;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">	    	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(</span><br><span class="line">	    		<span class="string">&quot;Failed to process import candidates for configuration class [&quot;</span> +</span><br><span class="line">			configClass.getMetadata().getClassName() + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">finally</span> &#123;</span><br><span class="line">		    <span class="built_in">this</span>.importStack.pop();</span><br><span class="line">	    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由此可以看出处理 <code>@Import</code> 中的类可以分为三种模式</p>
<ul>
<li>当成 <code>ImportSelector</code> 处理</li>
<li>当成 <code>ImportBeanDefinitionRegistrar</code> 处理</li>
<li>当成 <code>@Configuration</code> 处理</li>
</ul>
<p>先看一下 <code>ImportSelector</code> 这个接口的主要作用就是选择导入其他的类</p>
<p><code>ImportBeanDefinitionRegistrar</code> 则是通过 <code>registerBeanDefinitions</code> 方法去实现加载注册 <code>bean</code> 到 <code>beanFactory</code> 中</p>
<p>如果其不是上述任何一种则以该类型为资源类直接调用一次 <code>processConfigurationClass</code> 方法去加载</p>
]]></content>
      <categories>
        <category>spring</category>
        <category>annotation</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>annotation</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis-plus 基础 CURD 加载学习</title>
    <url>/2022/10/04/mybatis-plus%20%E5%9F%BA%E7%A1%80%20curd%20%E5%8A%A0%E8%BD%BD%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="mybatis-plus-基础-CURD-加载学习"><a href="#mybatis-plus-基础-CURD-加载学习" class="headerlink" title="mybatis-plus 基础 CURD 加载学习"></a>mybatis-plus 基础 CURD 加载学习</h1><h2 id="mybatis-spring-源码学习"><a href="#mybatis-spring-源码学习" class="headerlink" title="mybatis-spring 源码学习"></a>mybatis-spring 源码学习</h2><p><code>mybatis-spring</code> 这个 <code>jar</code> 可以是 <code>mybatis</code> 的代码无缝的融合到 <code>spring</code> 中</p>
<p>在 <code>mybatis-spring</code> 这个 <code>jar</code> 包中我们的 <code>*Mapper</code> 也就是类上打了 <code>@Mapper</code> 注解, 会被注册为 <code>FactoryBean</code> 的子类 <code>MapperFactoryBean</code> 的类</p>
<p>同时 <code>MapperFactoryBean</code> 这个类也继承了 <code>SqlSessionDaoSupport</code> 这个类同时也是 <code>DaoSupport</code> 的子类, 在<code>DaoSupport</code>其中实现了一个初始化的方法</p>
<p><code>DaoSupport.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> IllegalArgumentException, BeanInitializationException &#123;</span><br><span class="line">	<span class="comment">// Let abstract subclasses check their configuration.</span></span><br><span class="line">	checkDaoConfig();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Let concrete implementations initialize themselves.</span></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		initDao();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanInitializationException</span>(<span class="string">&quot;Initialization of DAO failed&quot;</span>, ex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>DaoSupport</code> 是 <code>spring</code> 框架中的一个类, 用于 <code>spring</code> 扩展特定的 <code>dao</code> 类</p>
<p>在 <code>MapperFactoryBean</code> 中也实现了 <code>checkDaoConfig</code> 这个方法去检查本身的 <code>DAO</code> 配置</p>
<p>代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">checkDaoConfig</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.checkDaoConfig();</span><br><span class="line"></span><br><span class="line">    notNull(<span class="built_in">this</span>.mapperInterface, <span class="string">&quot;Property &#x27;mapperInterface&#x27; is required&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Configuration</span> <span class="variable">configuration</span> <span class="operator">=</span> getSqlSession().getConfiguration();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.addToConfig &amp;&amp; !configuration.hasMapper(<span class="built_in">this</span>.mapperInterface)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            configuration.addMapper(<span class="built_in">this</span>.mapperInterface);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;Error while adding the mapper &#x27;&quot;</span> + <span class="built_in">this</span>.mapperInterface + <span class="string">&quot;&#x27; to configuration.&quot;</span>, e);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ErrorContext.instance().reset();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="mybatis-plus-中-addMapper"><a href="#mybatis-plus-中-addMapper" class="headerlink" title="mybatis-plus 中 addMapper"></a><code>mybatis-plus</code> 中 <code>addMapper</code></h2><p>有上述可知所有打了 <code>@Mapper</code> 注解的类都是需要被加载</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">configuration.addMapper(<span class="built_in">this</span>.mapperInterface);</span><br></pre></td></tr></table></figure>

<p>这样一句话的, 其中关键的显然是 <code>configuration</code> 的获取, 其的获取是在父类中对于 <code>SqlSessionTemplate</code> 的设置而得到的, 其中的 <code>Configuration</code> 是由 <code>MybatisConfiguration</code> 提供的 <code>addMapper</code> 源码如下</p>
<p><code>MybatisConfiguration.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">addMapper</span><span class="params">(Class&lt;T&gt; type)</span> &#123;</span><br><span class="line">    mybatisMapperRegistry.addMapper(type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时 <code>MybatisMapperRegistry</code> 也是由 <code>mybatis-plus</code> 官方实现的源码如下</p>
<p><code>MybatisMapperRegistry.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">addMapper</span><span class="params">(Class&lt;T&gt; type)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (type.isInterface()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasMapper(type)) &#123;</span><br><span class="line">            <span class="comment">// TODO 如果之前注入 直接返回</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">// TODO 这里就不抛异常了</span></span><br><span class="line"><span class="comment">//                throw new BindingException(&quot;Type &quot; + type + &quot; is already known to the MapperRegistry.&quot;);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">loadCompleted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// TODO 这里也换成 MybatisMapperProxyFactory 而不是 MapperProxyFactory</span></span><br><span class="line">            knownMappers.put(type, <span class="keyword">new</span> <span class="title class_">MybatisMapperProxyFactory</span>&lt;&gt;(type));</span><br><span class="line">            <span class="comment">// It&#x27;s important that the type is added before the parser is run</span></span><br><span class="line">            <span class="comment">// otherwise the binding may automatically be attempted by the</span></span><br><span class="line">            <span class="comment">// mapper parser. If the type is already known, it won&#x27;t try.</span></span><br><span class="line">            <span class="comment">// TODO 这里也换成 MybatisMapperAnnotationBuilder 而不是 MapperAnnotationBuilder</span></span><br><span class="line">            <span class="type">MybatisMapperAnnotationBuilder</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisMapperAnnotationBuilder</span>(config, type);</span><br><span class="line">            parser.parse();</span><br><span class="line">            loadCompleted = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!loadCompleted) &#123;</span><br><span class="line">                knownMappers.remove(type);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出其对解析器的创建使用的是 <code>MybatisMapperAnnotationBuilder</code> 这个自定义的类, 源码如下</p>
<p><code>MybatisMapperAnnotationBuilder.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parse</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> type.toString();</span><br><span class="line">    <span class="keyword">if</span> (!configuration.isResourceLoaded(resource)) &#123;</span><br><span class="line">        loadXmlResource();</span><br><span class="line">        configuration.addLoadedResource(resource);</span><br><span class="line">        <span class="type">String</span> <span class="variable">mapperName</span> <span class="operator">=</span> type.getName();</span><br><span class="line">        assistant.setCurrentNamespace(mapperName);</span><br><span class="line">        parseCache();</span><br><span class="line">        parseCacheRef();</span><br><span class="line">        InterceptorIgnoreHelper.<span class="type">InterceptorIgnoreCache</span> <span class="variable">cache</span> <span class="operator">=</span> InterceptorIgnoreHelper.initSqlParserInfoCache(type);</span><br><span class="line">        <span class="keyword">for</span> (Method method : type.getMethods()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!canHaveStatement(method)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (getAnnotationWrapper(method, <span class="literal">false</span>, Select.class, SelectProvider.class).isPresent()</span><br><span class="line">                    &amp;&amp; method.getAnnotation(ResultMap.class) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    parseResultMap(method);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// TODO 加入 注解过滤缓存</span></span><br><span class="line">                InterceptorIgnoreHelper.initSqlParserInfoCache(cache, mapperName, method);</span><br><span class="line">                    parseStatement(method);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IncompleteElementException e) &#123;</span><br><span class="line">                <span class="comment">// TODO 使用 MybatisMethodResolver 而不是 MethodResolver</span></span><br><span class="line">                configuration.addIncompleteMethod(<span class="keyword">new</span> <span class="title class_">MybatisMethodResolver</span>(<span class="built_in">this</span>, method));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// TODO 注入 CURD 动态 SQL , 放在在最后, because 可能会有人会用注解重写sql</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// https://github.com/baomidou/mybatis-plus/issues/3038</span></span><br><span class="line">            <span class="keyword">if</span> (GlobalConfigUtils.isSupperMapperChildren(configuration, type)) &#123;</span><br><span class="line">                    parserInjector();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IncompleteElementException e) &#123;</span><br><span class="line">            configuration.addIncompleteMethod(<span class="keyword">new</span> <span class="title class_">InjectorResolver</span>(<span class="built_in">this</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    parsePendingMethods();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中对于 <code>xml</code> 和方法之间的映射关系就不敢再论述, 和 <code>mybatis</code> 差不多, 主要是其如何自动加载基础的 <code>CURD</code> 方法的映射关系的</p>
<p>然后会调用 <code>AbstractSqlInjector</code> 类实现的 <code>inspectInject</code> 方法</p>
<p><code>AbstractSqlInjector.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inspectInject</span><span class="params">(MapperBuilderAssistant builderAssistant, Class&lt;?&gt; mapperClass)</span> &#123;</span><br><span class="line">    Class&lt;?&gt; modelClass = ReflectionKit.getSuperClassGenericType(mapperClass, Mapper.class, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (modelClass != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> mapperClass.toString();</span><br><span class="line">        Set&lt;String&gt; mapperRegistryCache = GlobalConfigUtils.getMapperRegistryCache(builderAssistant.getConfiguration());</span><br><span class="line">        <span class="keyword">if</span> (!mapperRegistryCache.contains(className)) &#123;</span><br><span class="line">            <span class="type">TableInfo</span> <span class="variable">tableInfo</span> <span class="operator">=</span> TableInfoHelper.initTableInfo(builderAssistant, modelClass);</span><br><span class="line">            List&lt;AbstractMethod&gt; methodList = <span class="built_in">this</span>.getMethodList(mapperClass, tableInfo);</span><br><span class="line">            <span class="keyword">if</span> (CollectionUtils.isNotEmpty(methodList)) &#123;</span><br><span class="line">                <span class="comment">// 循环注入自定义方法</span></span><br><span class="line">                methodList.forEach(m -&gt; m.inject(builderAssistant, mapperClass, modelClass, tableInfo));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                logger.debug(mapperClass.toString() + <span class="string">&quot;, No effective injection method was found.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            mapperRegistryCache.add(className);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>他是通过一个 <code>getMethodList</code> 方法去得到所有的在 <code>BaseMapper</code> 中注册的基础 <code>CURD</code> 方法, 然后每个被添加在 <code>getMethodList</code> 中的方法会实现一个名为 <code>inject</code> 的方法, 去动态注册方法和 <code>SQL</code> 的映射, 看一个实现</p>
<p><code>Delete.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> MappedStatement <span class="title function_">injectMappedStatement</span><span class="params">(Class&lt;?&gt; mapperClass, Class&lt;?&gt; modelClass, TableInfo tableInfo)</span> &#123;</span><br><span class="line">    String sql;</span><br><span class="line">    <span class="type">SqlMethod</span> <span class="variable">sqlMethod</span> <span class="operator">=</span> SqlMethod.LOGIC_DELETE;</span><br><span class="line">    <span class="keyword">if</span> (tableInfo.isWithLogicDelete()) &#123;</span><br><span class="line">        sql = String.format(sqlMethod.getSql(), tableInfo.getTableName(), sqlLogicSet(tableInfo),</span><br><span class="line">        sqlWhereEntityWrapper(<span class="literal">true</span>, tableInfo),</span><br><span class="line">        sqlComment());</span><br><span class="line">        <span class="type">SqlSource</span> <span class="variable">sqlSource</span> <span class="operator">=</span> languageDriver.createSqlSource(configuration, sql, modelClass);</span><br><span class="line">        <span class="keyword">return</span> addUpdateMappedStatement(mapperClass, modelClass, getMethod(sqlMethod), sqlSource);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sqlMethod = SqlMethod.DELETE;</span><br><span class="line">        sql = String.format(sqlMethod.getSql(), tableInfo.getTableName(),</span><br><span class="line">                sqlWhereEntityWrapper(<span class="literal">true</span>, tableInfo),</span><br><span class="line">                sqlComment());</span><br><span class="line">        <span class="type">SqlSource</span> <span class="variable">sqlSource</span> <span class="operator">=</span> languageDriver.createSqlSource(configuration, sql, modelClass);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.addDeleteMappedStatement(mapperClass, getMethod(sqlMethod), sqlSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在点进去一层查看 <code>addUpdateMappedStatement</code> 方法源码</p>
<p><code>AbstractMethod.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> MappedStatement <span class="title function_">addUpdateMappedStatement</span><span class="params">(Class&lt;?&gt; mapperClass, Class&lt;?&gt; parameterType, String id, SqlSource sqlSource)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> addMappedStatement(mapperClass, id, sqlSource, SqlCommandType.UPDATE, parameterType, <span class="literal">null</span>, Integer.class, NoKeyGenerator.INSTANCE, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看 <code>addMapperStatement</code> 的统一调用类</p>
<p><code>AbstractMethod.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> MappedStatement <span class="title function_">addMappedStatement</span><span class="params">(Class&lt;?&gt; mapperClass, String id, SqlSource sqlSource, SqlCommandType sqlCommandType, Class&lt;?&gt; parameterType, String resultMap, Class&lt;?&gt; resultType, KeyGenerator keyGenerator, String keyProperty, String keyColumn)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">statementName</span> <span class="operator">=</span> mapperClass.getName() + DOT + id;</span><br><span class="line">    <span class="keyword">if</span> (hasMappedStatement(statementName)) &#123;</span><br><span class="line">        logger.warn(LEFT_SQ_BRACKET + statementName + <span class="string">&quot;] Has been loaded by XML or SqlProvider or Mybatis&#x27;s Annotation, so ignoring this injection for [&quot;</span> + getClass() + RIGHT_SQ_BRACKET);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 缓存逻辑处理 */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isSelect</span> <span class="operator">=</span> sqlCommandType == SqlCommandType.SELECT;</span><br><span class="line">    <span class="keyword">return</span> builderAssistant.addMappedStatement(id, sqlSource, StatementType.PREPARED, sqlCommandType, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, parameterType, resultMap, resultType, <span class="literal">null</span>, !isSelect, isSelect, <span class="literal">false</span>, keyGenerator, keyProperty, keyColumn, configuration.getDatabaseId(), languageDriver, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到此将一切数据准备好并交由 <code>mybatis</code> 的 <code>addMappedStatement</code> 方法去处理映射关系</p>
]]></content>
      <categories>
        <category>mybatis-plus</category>
      </categories>
      <tags>
        <tag>mybatis-spring</tag>
        <tag>mybatis-plus</tag>
      </tags>
  </entry>
  <entry>
    <title>心跳机制实现</title>
    <url>/2022/10/10/%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="心跳机制实现"><a href="#心跳机制实现" class="headerlink" title="心跳机制实现"></a>心跳机制实现</h1><h2 id="心跳机制原理"><a href="#心跳机制原理" class="headerlink" title="心跳机制原理"></a>心跳机制原理</h2><p>客户端或者说是服务提供者(需要被注册的服务)需要每隔一段时间向服务端或者服务发现者发送一个数据包, 同时在服务端接收到服务包之后也会返回一个数据包相应客户端, 如果双方在一定时间内没有接收到对方的数据表, 则断开连接</p>
<h2 id="心跳机制技术"><a href="#心跳机制技术" class="headerlink" title="心跳机制技术"></a>心跳机制技术</h2><ol>
<li><p><code>TCP</code></p>
<p> 在 <code>TCP</code> 的机制中本身就带有心跳机制, 只要一方开启 <code>KeepAlive</code> 功能以后, 就会自动在规定时间内向对方发送数据包</p>
</li>
<li><p>应用层自定义心跳包</p>
<p> 客户端启动一个线程定时向服务端发送数据表, 同时服务端启动一个线程维护客户端发送数据包的时间是否出现异常</p>
</li>
</ol>
<h2 id="自定义实现"><a href="#自定义实现" class="headerlink" title="自定义实现"></a>自定义实现</h2><p><code>HeartbeatServer.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.rupa.test.server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentMap;</span><br><span class="line"><span class="keyword">import</span> java.util.logging.Logger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeartbeatServer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> Logger.getLogger(HeartbeatServer.class.getName());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ConcurrentMap&lt;Socket, Long&gt; clientMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ServerSocket serverSocket;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">TIME_OUT</span> <span class="operator">=</span> <span class="number">30</span> * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 服务器接口</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startup</span><span class="params">(<span class="type">int</span> port)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.port = port;</span><br><span class="line"></span><br><span class="line">            serverSocket = <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(port);</span><br><span class="line">            log.info(<span class="string">&quot;服务器启动&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">                log.info(<span class="string">&quot;客户端 &quot;</span> + socket.getInetAddress() + <span class="string">&quot;:&quot;</span> + socket.getPort() + <span class="string">&quot; 已经加载&quot;</span>);</span><br><span class="line">                clientMap.put(socket, <span class="number">0L</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">HeartbeatSend</span>(socket), <span class="string">&quot;Send &quot;</span> + socket.getInetAddress() + <span class="string">&quot;:&quot;</span> + socket.getPort()).start();</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">HeartReceive</span>(socket), <span class="string">&quot;Receive &quot;</span> + socket.getInetAddress() + <span class="string">&quot;:&quot;</span> + socket.getPort()).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">(String msg, Socket socket)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">printWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(outputStream);</span><br><span class="line">        printWriter.println(msg);</span><br><span class="line">        printWriter.flush();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">receiveMsg</span><span class="params">(Socket socket)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="type">InputStreamReader</span> <span class="variable">inputStreamReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(inputStream);</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(inputStreamReader);</span><br><span class="line">        <span class="keyword">return</span> bufferedReader.readLine();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">HeartReceive</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> Socket socket;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">HeartReceive</span><span class="params">(Socket socket)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.socket = socket;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"></span><br><span class="line">                <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> receiveMsg(socket);</span><br><span class="line"></span><br><span class="line">                log.info(<span class="string">&quot;接收到客户端&quot;</span> + socket.getInetAddress() + <span class="string">&quot;:&quot;</span> + socket.getPort() + <span class="string">&quot;心跳时间 &quot;</span>  + date.getTime());</span><br><span class="line"></span><br><span class="line">                clientMap.put(socket, date.getTime());</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">HeartbeatSend</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> Socket socket;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">HeartbeatSend</span><span class="params">(Socket socket)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.socket = socket;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 客户端相应超时</span></span><br><span class="line">                    <span class="keyword">if</span> (clientMap.get(socket) != <span class="number">0</span> &amp;&amp; (date.getTime() - clientMap.get(socket)) &gt; TIME_OUT) &#123;</span><br><span class="line">                        clientMap.remove(socket);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    log.info(<span class="string">&quot;回复心跳时间  &quot;</span> + date.getTime());</span><br><span class="line"></span><br><span class="line">                    sendMsg(<span class="string">&quot;keep&quot;</span>, socket);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">HeartbeatServer</span>().startup(<span class="number">8080</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>HeartbeatClient.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.rupa.test.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.xml.crypto.Data;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.logging.Logger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeartbeatClient</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> Logger.getLogger(HeartbeatClient.class.getName());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">TIME_OUT</span> <span class="operator">=</span> <span class="number">30</span> * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务器最后一次相应时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Long</span> <span class="variable">lastServerFeedbackTime</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务器端口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> serverPort;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startup</span><span class="params">(<span class="type">int</span> serverPort)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.serverPort = serverPort;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socket = <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, serverPort);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">HeartReceive</span>(), <span class="string">&quot;receive&quot;</span>).start();</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">HeartbeatSend</span>(), <span class="string">&quot;send&quot;</span>).start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">(String msg)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">printWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(outputStream);</span><br><span class="line">        printWriter.println(msg);</span><br><span class="line">        printWriter.flush();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">receiveMsg</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="type">InputStreamReader</span> <span class="variable">inputStreamReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(inputStream);</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(inputStreamReader);</span><br><span class="line">        <span class="keyword">return</span> bufferedReader.readLine();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">HeartReceive</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"></span><br><span class="line">                <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> receiveMsg();</span><br><span class="line"></span><br><span class="line">                log.info(<span class="string">&quot;服务器相应时间 &quot;</span> + date.getTime());</span><br><span class="line"></span><br><span class="line">                lastServerFeedbackTime = date.getTime();</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">HeartbeatSend</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 服务器相应超时</span></span><br><span class="line">                    <span class="keyword">if</span> (lastServerFeedbackTime != <span class="number">0</span> &amp;&amp; (date.getTime() - lastServerFeedbackTime) &gt; TIME_OUT) &#123;</span><br><span class="line">                        System.exit(<span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    log.info(<span class="string">&quot;发送心跳时间  &quot;</span> + date.getTime());</span><br><span class="line"></span><br><span class="line">                    sendMsg(<span class="string">&quot;keep&quot;</span>);</span><br><span class="line"></span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException | InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">HeartbeatClient</span>().startup(<span class="number">8080</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>micro service</category>
      </categories>
      <tags>
        <tag>micro service</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 实现 消费者-生产者 模型</title>
    <url>/2023/08/04/Java%20%E5%AE%9E%E7%8E%B0%20%E6%B6%88%E8%B4%B9%E8%80%85-%E7%94%9F%E4%BA%A7%E8%80%85%20%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="消费者-生产者-模型"><a href="#消费者-生产者-模型" class="headerlink" title="消费者-生产者 模型"></a>消费者-生产者 模型</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>在生产者／消费者模型中，生产者Producer负责生产数据，而消费者Consumer负责使用数据。多个生产者线程会在同一时间运行，生产数据，并放到内存中一个共享的区域</p>
<h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ul>
<li><p>解耦 <br/></p>
<p>  将生产者类和消费者类进行解耦，消除代码之间的依赖性，简化工作负载的管理。</p>
</li>
<li><p>支持分布式 <br/><br>  生产者和消费者通过队列进行通讯，所以不需要运行在同一台机器上，在分布式环境中可以通过 redis 的 list 作为队列，而消费者只需要轮询队列中是否有数据。同时还能支持集群的伸缩性，当某台机器宕掉的时候，不会导致整个集群宕掉。</p>
</li>
<li><p>复用 <br/><br>  通过将生产者类和消费者类独立开来，那么可以对生产者类和消费者类进行独立的复用与扩展。</p>
</li>
<li><p>调整并发数 <br/><br>  由于生产者和消费者的处理速度是不一样的，可以调整并发数，给予慢的一方多的并发数，来提高任务的处理速度。</p>
</li>
<li><p>异步 <br/><br>  对于生产者和消费者来说能够各司其职，生产者只需要关心缓冲区是否还有数据，不需要等待消费者处理完；同样的对于消费者来说，也只需要关注缓冲区的内容，不需要关注生产者，通过异步的方式支持高并发，将一个耗时的流程拆成生产和消费两个阶段，这样生产者因为执行 put() 的时间比较短，而支持高并发。</p>
</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p><code>Consumer.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">consumer</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Producer.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Producer</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">producer</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>AbstractConsumer.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractConsumer</span> <span class="keyword">implements</span> <span class="title class_">Consumer</span>, Runnable &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                consumer();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>AbstractProducer.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractProducer</span> <span class="keyword">implements</span> <span class="title class_">Producer</span>, Runnable &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            producer();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Model.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Model</span> &#123;</span><br><span class="line">    Runnable <span class="title function_">runnableConsumer</span><span class="params">()</span>;</span><br><span class="line">    Runnable <span class="title function_">runnableProducer</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h3><p><code>BlockingQueueModel.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlockingQueueModel</span> <span class="keyword">implements</span> <span class="title class_">Model</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Integer&gt; queue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BlockingQueueModel</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.queue = <span class="keyword">new</span> <span class="title class_">LinkedBlockingDeque</span>&lt;&gt;(cap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Runnable <span class="title function_">runnableConsumer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConsumerImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Runnable <span class="title function_">runnableProducer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProducerImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerImpl</span> <span class="keyword">extends</span> <span class="title class_">AbstractConsumer</span> <span class="keyword">implements</span> <span class="title class_">Consumer</span>, Runnable &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">consumer</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> queue.take();</span><br><span class="line">            Thread.sleep(<span class="number">500</span> + (<span class="type">long</span>) (Math.random() * <span class="number">500</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;处理任务 &quot;</span> + integer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerImpl</span> <span class="keyword">extends</span> <span class="title class_">AbstractProducer</span> <span class="keyword">implements</span> <span class="title class_">Producer</span>, Runnable &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">producer</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">            Thread.sleep((<span class="type">long</span>) (Math.random() * <span class="number">1000</span>));</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> atomicInteger.getAndIncrement();</span><br><span class="line">            System.out.println(<span class="string">&quot;生产任务: &quot;</span> + integer);</span><br><span class="line">            queue.put(integer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Model</span> <span class="variable">model</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BlockingQueueModel</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(model.runnableConsumer()).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(model.runnableProducer()).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Wait-amp-amp-Notify"><a href="#Wait-amp-amp-Notify" class="headerlink" title="Wait &amp;&amp; Notify"></a>Wait &amp;&amp; Notify</h3><p><code>WaitNotifyModel.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaitNotifyModel</span> <span class="keyword">implements</span> <span class="title class_">Model</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">BUFFER_LOCK</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> cap;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WaitNotifyModel</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cap = cap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Runnable <span class="title function_">runnableConsumer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConsumerImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Runnable <span class="title function_">runnableProducer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProducerImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerImpl</span> <span class="keyword">extends</span> <span class="title class_">AbstractConsumer</span> <span class="keyword">implements</span> <span class="title class_">Consumer</span>, Runnable &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">consumer</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (BUFFER_LOCK) &#123;</span><br><span class="line">                <span class="keyword">while</span> (queue.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                    BUFFER_LOCK.wait();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                Thread.sleep(<span class="number">500</span> + (<span class="type">long</span>) (Math.random() * <span class="number">500</span>));</span><br><span class="line">                System.out.println(<span class="string">&quot;处理任务 &quot;</span> + integer);</span><br><span class="line">                BUFFER_LOCK.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerImpl</span> <span class="keyword">extends</span> <span class="title class_">AbstractProducer</span> <span class="keyword">implements</span> <span class="title class_">Producer</span>, Runnable &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">producer</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">            Thread.sleep((<span class="type">long</span>) (Math.random() * <span class="number">1000</span>));</span><br><span class="line">            <span class="keyword">synchronized</span> (BUFFER_LOCK) &#123;</span><br><span class="line">                <span class="keyword">while</span> (queue.size() == cap) &#123;</span><br><span class="line">                    BUFFER_LOCK.wait();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> atomicInteger.getAndIncrement();</span><br><span class="line">                queue.offer(integer);</span><br><span class="line">                System.out.println(<span class="string">&quot;生产任务: &quot;</span> + integer);</span><br><span class="line">                BUFFER_LOCK.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Model</span> <span class="variable">model</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BlockingQueueModel</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(model.runnableConsumer()).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(model.runnableProducer()).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Lock-amp-amp-Condition"><a href="#Lock-amp-amp-Condition" class="headerlink" title="Lock &amp;&amp; Condition"></a>Lock &amp;&amp; Condition</h3><p><code>LockConditionModel.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockConditionModel</span> <span class="keyword">implements</span> <span class="title class_">Model</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">BUFFER_LOCK</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">BUFFER_COND</span> <span class="operator">=</span> BUFFER_LOCK.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> cap;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LockConditionModel</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cap = cap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Runnable <span class="title function_">runnableConsumer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConsumerImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Runnable <span class="title function_">runnableProducer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProducerImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerImpl</span> <span class="keyword">extends</span> <span class="title class_">AbstractConsumer</span> <span class="keyword">implements</span> <span class="title class_">Consumer</span>, Runnable &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">consumer</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">            BUFFER_LOCK.lockInterruptibly();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (queue.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                    BUFFER_COND.await();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                Thread.sleep(<span class="number">500</span> + (<span class="type">long</span>) (Math.random() * <span class="number">500</span>));</span><br><span class="line">                System.out.println(<span class="string">&quot;处理任务 &quot;</span> + integer);</span><br><span class="line">                BUFFER_COND.notifyAll();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                BUFFER_LOCK.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerImpl</span> <span class="keyword">extends</span> <span class="title class_">AbstractProducer</span> <span class="keyword">implements</span> <span class="title class_">Producer</span>, Runnable &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">producer</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">            Thread.sleep((<span class="type">long</span>) (Math.random() * <span class="number">1000</span>));</span><br><span class="line">            BUFFER_LOCK.lockInterruptibly();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (queue.size() == cap) &#123;</span><br><span class="line">                    BUFFER_COND.wait();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> atomicInteger.getAndIncrement();</span><br><span class="line">                queue.offer(integer);</span><br><span class="line">                System.out.println(<span class="string">&quot;生产任务: &quot;</span> + integer);</span><br><span class="line">                BUFFER_COND.notifyAll();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">              BUFFER_LOCK.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Model</span> <span class="variable">model</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BlockingQueueModel</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(model.runnableConsumer()).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(model.runnableProducer()).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul>
<li><a href="https://www.cnblogs.com/horacle/p/15425808.html">https://www.cnblogs.com/horacle/p/15425808.html</a></li>
<li><a href="https://monkeysayhi.github.io/2017/10/08/Java%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/">https://monkeysayhi.github.io/2017/10/08/Java%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/</a></li>
</ul>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
</search>
