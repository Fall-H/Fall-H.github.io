<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>bean 相关源码学习</title>
    <url>/2022/07/12/bean%20%E7%9B%B8%E5%85%B3%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="获取-bean-的方案"><a href="#获取-bean-的方案" class="headerlink" title="获取 bean 的方案"></a>获取 <code>bean</code> 的方案</h1><h2 id="创建类的标准的方案"><a href="#创建类的标准的方案" class="headerlink" title="创建类的标准的方案"></a>创建类的标准的方案</h2><ol>
<li>BeanNameAware’s setBeanName</li>
<li>BeanClassLoaderAware’s setBeanClassLoader</li>
<li>BeanFactoryAware’s setBeanFactory</li>
<li>EnvironmentAware’s setEnvironment</li>
<li>EmbeddedValueResolverAware’s setEmbeddedValueResolver</li>
<li>ResourceLoaderAware’s setResourceLoader (only applicable when running in an application context)<br>ApplicationEventPublisherAware’s<br>setApplicationEventPublisher (only applicable when running in an application context)</li>
<li>MessageSourceAware’s setMessageSource (only applicable when running in an application context)</li>
<li>ApplicationContextAware’s setApplicationContext (only applicable when running in an application context)</li>
<li>ServletContextAware’s setServletContext (only applicable when running in a web application context)<br>postProcessBeforeInitialization methods of BeanPostProcessors</li>
<li>InitializingBean’s afterPropertiesSet<br>a custom init-method definition<br>postProcessAfterInitialization methods of BeanPostProcessors</li>
</ol>
<h2 id="当-bean-factory-被销毁时"><a href="#当-bean-factory-被销毁时" class="headerlink" title="当 bean factory 被销毁时"></a>当 <code>bean factory</code> 被销毁时</h2><ol>
<li>postProcessBeforeDestruction methods of DestructionAwareBeanPostProcessors</li>
<li>DisposableBean’s destroy</li>
<li>a custom destroy-method definition</li>
</ol>
<h1 id="创建-bean-的过程"><a href="#创建-bean-的过程" class="headerlink" title="创建 bean 的过程"></a>创建 <code>bean</code> 的过程</h1><p>调用 <code>beanfactory</code> 中的 <code>getBean</code> 中的方法得到类的实体</p>
<p>其中方法中可以使用 <code>name</code> <code>requiredType</code> <code>args</code> 得到特定的类型</p>
<p>进入 <code>getBean</code> 之后进入 <code>doGetBean</code> 方法统一处理所有的 <code>getBean</code> </p>
<p>在先去单例缓存中尝试取出 <code>bean</code> 如果没有 <code>bean</code> 通过 <code>singleton</code> 和 <code>prototype</code> 判断是创建单例还是原型</p>
<ol>
<li><p>单例</p>
<p> 调用 <code>createBean</code> 方法 创建 <code>bean</code> 同时注册进单例缓存中</p>
<p> 调用 <code>getObjectForBeanInstance</code> 创建 <code>bean</code></p>
</li>
<li><p>原型</p>
<p>调用 <code>beforePrototypeCreation</code></p>
<p>调用 <code>createBean</code> 方法 创建 <code>bean</code></p>
<p>调用 <code>afterPrototypeCreation</code></p>
<p>调用 <code>getObjectForBeanInstance</code> 创建 <code>bean</code></p>
</li>
</ol>
<p><small> <code>getObjectForBeanInstance</code> 这个方法 主要是获取给定 bean 实例的对象，bean 实例本身或其创建的对象（如果是 FactoryBean） </small></p>
<p>然后就是进入 <code>createBean</code> 方法之中 通过这个方法创建 <code>bean</code> 的实例 填充 <code>bean</code> 的实例 执行 <code>postprocessors</code></p>
<p>执行 <code>doCreateBean</code> 方法 加载创建类的细节</p>
<p>在 <code>doCreateBean</code> 方法中</p>
<ol>
<li>填充 <code>bean</code> 中的字段</li>
<li>初始化 <code>bean</code> </li>
<li>通过 <code>earlySingletonExposure</code> 解决依赖循环的问题</li>
<li>将该 <code>bean</code> 注册进 <code>disposable</code> 列表中</li>
</ol>
<p>返回类型</p>
<p>得到 <code>bean</code> 的整体流程结束</p>
]]></content>
  </entry>
</search>
