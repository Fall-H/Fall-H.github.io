<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>GetBean 相关源码学习</title>
    <url>/2022/07/11/bean%20%E7%9B%B8%E5%85%B3%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="创建-bean-的过程"><a href="#创建-bean-的过程" class="headerlink" title="创建 bean 的过程"></a>创建 <code>bean</code> 的过程</h1><p>调用 <code>beanfactory</code> 中的 <code>getBean</code> 中的方法得到类的实体</p>
<p>其中方法中可以使用 <code>name</code> <code>requiredType</code> <code>args</code> 得到特定的类型</p>
<p>有如下签名</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object <span class="title function_">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line">&lt;T&gt; T <span class="title function_">getBean</span><span class="params">(String name, Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line">Object <span class="title function_">getBean</span><span class="params">(String name, Object... args)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line">&lt;T&gt; T <span class="title function_">getBean</span><span class="params">(Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line">&lt;T&gt; T <span class="title function_">getBean</span><span class="params">(Class&lt;T&gt; requiredType, Object... args)</span> <span class="keyword">throws</span> BeansException;</span><br></pre></td></tr></table></figure>

<p>进入 <code>getBean</code> 之后进入 <code>doGetBean</code> 方法统一处理所有的 <code>getBean</code> </p>
<p>在先去单例缓存中尝试取出 <code>bean</code> 如果没有 <code>bean</code> 通过 <code>singleton</code> 和 <code>prototype</code> 判断是创建单例还是原型</p>
<ol>
<li>单例</li>
</ol>
<p><code>AbstractBeanFactory.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">	    <span class="comment">// 从单例缓存中显式删除实例：它可能已经放在那里</span></span><br><span class="line">	    <span class="comment">// 急切地通过创建过程，以允许循环引用解析。</span></span><br><span class="line">	    <span class="comment">// 还要删除任何接收到对 bean 的临时引用的 bean。</span></span><br><span class="line">	    destroySingleton(beanName);</span><br><span class="line">	    <span class="keyword">throw</span> ex;</span><br><span class="line">	&#125;</span><br><span class="line">);</span><br><span class="line">beanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br></pre></td></tr></table></figure>

<p>调用 <code>createBean</code> 方法 创建 <code>bean</code> 同时注册进单例缓存中</p>
<p>调用 <code>getObjectForBeanInstance</code> 创建 <code>bean</code></p>
<ol start="2">
<li>原型</li>
</ol>
<p><code>AbstractBeanFactory.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">prototypeInstance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	beforePrototypeCreation(beanName);</span><br><span class="line">	prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">	afterPrototypeCreation(beanName);</span><br><span class="line">&#125;</span><br><span class="line">beanInstance = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br></pre></td></tr></table></figure>

<p>调用 <code>beforePrototypeCreation</code></p>
<p>调用 <code>createBean</code> 方法 创建 <code>bean</code></p>
<p>调用 <code>afterPrototypeCreation</code></p>
<p>调用 <code>getObjectForBeanInstance</code> 创建 <code>bean</code></p>
<p><small> <code>getObjectForBeanInstance</code> 这个方法 主要是获取给定 bean 实例的对象，bean 实例本身或其创建的对象（如果是 FactoryBean） </small></p>
<p>然后就是进入 <code>createBean</code> 方法之中执行 <code>doCreateBean</code> 方法加载创建类的细节</p>
<h1 id="在-doCreateBean-方法中"><a href="#在-doCreateBean-方法中" class="headerlink" title="在 doCreateBean 方法中"></a>在 <code>doCreateBean</code> 方法中</h1><ol>
<li><p>实例化 <code>bean</code> 调用 <code>createBeanInstance</code></p>
<ol>
<li>如果是通过 <code>@Bean</code> 加载 <code>bean</code> 的话，调用 <code>instantiateUsingFactoryMethod</code> 通过方法实例化</li>
<li>匹配类的构造器，通过构造器将类实例化</li>
</ol>
</li>
<li><p>填充 <code>bean</code> 中的字段</p>
<ol>
<li>填充字段的方案是由 <code>RootBeanDefinition</code> 这个包装类中的 <code>PropertyValues</code> 字段</li>
<li>主要是调用 <code>applyPropertyValues</code> 这个方法去填充字段 </li>
<li>如果使用注解的方式加载 <code>bean</code> 的话还会加载 <code>AutowiredAnnotationProcessor</code> 这样一个类，在填充的会使用其实现的一个 <code>postProcessProperties</code> 方式读取带有 <code>@Autowired</code> 的代码进行代码字段的注入</li>
</ol>
</li>
<li><p>初始化 <code>bean</code> </p>
<ol>
<li>调用 <code>Aware</code> 容器感知功能其执行的顺序是 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BeanNameAware</span><br><span class="line">BeanClassLoaderAware</span><br><span class="line">BeanFactoryAware</span><br></pre></td></tr></table></figure>
 通过这些方法可以在当前 <code>bean</code> 中后的例如: <code>bean name</code> <code>class loader</code> <code>bean factory</code> 等一些基础信息</li>
<li>调用 <code>BeanPostProcessor</code> 中的 <code>postProcessBeforeInitialization</code></li>
<li>调用用户自定义的 <code>init method</code></li>
<li>调用 <code>BeanPostProcessor</code> 中的 <code>postProcessAfterInitialization</code></li>
</ol>
</li>
<li><p>通过 <code>earlySingletonExposure</code> 解决依赖循环的问题</p>
</li>
<li><p>将该 <code>bean</code> 注册进 <code>disposable</code> 列表中</p>
</li>
</ol>
<p>返回类型</p>
<p>得到 <code>bean</code> 的整体流程结束</p>
]]></content>
      <categories>
        <category>spring</category>
        <category>ioc</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>ioc</tag>
      </tags>
  </entry>
  <entry>
    <title>读取 bean 相关源码学习</title>
    <url>/2022/07/14/%E8%AF%BB%E5%8F%96%20bean%20%E7%9B%B8%E5%85%B3%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="读取-bean-的过程"><a href="#读取-bean-的过程" class="headerlink" title="读取 bean 的过程"></a>读取 <code>bean</code> 的过程</h1><p>创建对象 <code>ClassPathXmlApplicationContext</code></p>
<p>通过 <code>refresh</code> 进行加载</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StartupStep</span> <span class="variable">contextRefresh</span> <span class="operator">=</span> <span class="built_in">this</span>.applicationStartup.start(<span class="string">&quot;spring.context.refresh&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 准备此上下文以进行刷新。</span></span><br><span class="line">prepareRefresh();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 告诉子类刷新内部 bean 工厂。</span></span><br><span class="line"><span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 准备 bean 工厂以在此上下文中使用。</span></span><br><span class="line">prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="comment">// 允许在上下文子类中对 bean 工厂进行后处理。</span></span><br><span class="line">	postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">	<span class="type">StartupStep</span> <span class="variable">beanPostProcess</span> <span class="operator">=</span> <span class="built_in">this</span>.applicationStartup.start(<span class="string">&quot;spring.context.beans.post-process&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 调用在上下文中注册为 bean 的工厂处理器。</span></span><br><span class="line">	invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 注册拦截 bean 创建的 bean 处理器。</span></span><br><span class="line">	registerBeanPostProcessors(beanFactory);</span><br><span class="line">	beanPostProcess.end();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 为此上下文初始化消息源。</span></span><br><span class="line">	initMessageSource();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 为此上下文初始化事件多播器。</span></span><br><span class="line">	initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化特定上下文子类中的其他特殊 bean。</span></span><br><span class="line">	onRefresh();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 检查侦听器 bean 并注册它们。</span></span><br><span class="line">	registerListeners();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 实例化所有剩余的（非惰性初始化）单例。</span></span><br><span class="line">	finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 最后一步：发布相应的事件。</span></span><br><span class="line">	finishRefresh();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">	<span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">		logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> + <span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 销毁已经创建的单例以避免悬空资源。</span></span><br><span class="line">	destroyBeans();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重置&#x27;活动&#x27;标志。</span></span><br><span class="line">	cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将异常传播给调用者。</span></span><br><span class="line">	<span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 重置 Spring 核心中的常见自省缓存，因为我们 </span></span><br><span class="line">    <span class="comment">// 可能不再需要单例 bean 的元数据...</span></span><br><span class="line">    resetCommonCaches();</span><br><span class="line">	contextRefresh.end();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个方法完成了 <code>spring</code> 三种加载 <code>bean</code> 的方法</p>
<ul>
<li>通过 <code>xml</code> 加载</li>
<li>通过 <code>java</code> 方法加载</li>
<li>通过 <code>spring</code> 自动加载</li>
</ul>
<h1 id="xml-读取方案"><a href="#xml-读取方案" class="headerlink" title="xml 读取方案"></a><code>xml</code> 读取方案</h1><p>方法流程 <code>obtainFreshBeanFactory</code> -&gt; <code>refreshBeanFactory</code> -&gt; <code>loadBeanDefinitions</code> -&gt; <code>doLoadBeanDefinitions</code> -&gt; <code>registerBeanDefinitions</code> -&gt; <code>doRegisterBeanDefinitions</code></p>
<p>然后在 <code>doRegisterBeanDefinitions</code> 在这个方法中使用解析 <code>xml</code> 的方法，在读取并拼装好 <code>bean</code> 的包装类 <code>BeanDefinition</code> 注册到全局唯一的 <code>beanFactory</code> 中</p>
<h1 id="java-方法加载"><a href="#java-方法加载" class="headerlink" title="java 方法加载"></a><code>java</code> 方法加载</h1><p>其主要是通过 <code>invokeBeanFactoryPostProcessors</code> 调用 <code>invokeBeanFactoryPostProcessors</code> 在这个方法内使用 <code>invokeBeanDefinitionRegistryPostProcessors</code> 方法通过 <code>BeanDefinitionRegistryPostProcessor</code> </p>
<p>所以现在的问题又变成其中的 <code>BeanDefinitionRegistryPostProcessor</code> 是如何出现的了和 <code>xml</code> 读取方式不同是的通过 <code>java</code> 代码打注解的方式加载 <code>bean</code> 必须使用 <code>AnnotationConfigApplicationContext</code> 这个加载类启动区别在于其多了一个 <code>scan</code> 或则 <code>register</code> 方法 ( 这取决你通过使用何种方式扫描 <code>bean</code></p>
<ul>
<li><code>scan</code>: 通过 <code>java</code> 包</li>
<li><code>register</code>: 通过配置类</li>
</ul>
<p>)</p>
<p>在 <code>register</code> 中的 <code>BeanDefinitionReaderUtils</code> 使用 <code>registerBeanDefinition</code> 去注册配置 <code>bean</code> 类的包装类</p>
<p>同时在创建 <code>AnnotationConfigApplicationContext</code> 类是，其会调用一些方法去注册固定的 <code>annotation post processon</code> 去完成 <code>@bean</code> 方法的注册</p>
<p>下面就是 <code>BeanDefinitionRegistryPostProcessor</code> 中到底做了什么</p>
<p>在 <code>BeanDefinitionRegistryPostProcessor</code> 中的一个实现子类 <code>ConfigurationClassPostProcessor</code> 是其解析和加载拥有 <code>@bean</code> 方法并且注册其的包装类</p>
<p>具体是怎么是做的呢</p>
<p>在 <code>processConfigBeanDefinitions</code> 这个方法中找出所有的 <code>@Configuration</code> 配置类，然后对每个配置类进项解析</p>
<p>在方法 <code>parse</code> 中去选择以何种方式调用 <code>processConfigurationClass</code> 在 <code>retrieveBeanMethodMetadata</code> 找出有 <code>@bean</code> 的方法，将其注册到 <code>ConfigurationClass</code> 中解析完成，<code>loadBeanDefinitions</code> 这个方法正常就是将 <code>bean</code> 包装注册。</p>
<h1 id="自动加载"><a href="#自动加载" class="headerlink" title="自动加载"></a>自动加载</h1><p>其加载方式和通过 <code>@bean</code> 加载代码的方式差不多你需要在类上打上 <code>@component</code> 这个注解以便让 <code>spring</code> 中 <code>@componentScan</code> 这个注解可以加载其</p>
<p>和上面的加载方式一样进入 <code>doProcessConfigurationClass</code> 方法只不过其调用其中的 <code>componentScanParser.parse</code> 方法去扫描所有的类看其实是否拥有 <code>@component</code> 注解如果有则将其包装注册 </p>
]]></content>
      <categories>
        <category>spring</category>
        <category>ioc</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>ioc</tag>
      </tags>
  </entry>
</search>
