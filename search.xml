<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>GetBean 相关源码学习</title>
    <url>/2022/07/11/bean%20%E7%9B%B8%E5%85%B3%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="创建-bean-的过程"><a href="#创建-bean-的过程" class="headerlink" title="创建 bean 的过程"></a>创建 <code>bean</code> 的过程</h1><p>调用 <code>beanfactory</code> 中的 <code>getBean</code> 中的方法得到类的实体</p>
<p>其中方法中可以使用 <code>name</code> <code>requiredType</code> <code>args</code> 得到特定的类型</p>
<p>有如下签名</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object <span class="title function_">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line">&lt;T&gt; T <span class="title function_">getBean</span><span class="params">(String name, Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line">Object <span class="title function_">getBean</span><span class="params">(String name, Object... args)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line">&lt;T&gt; T <span class="title function_">getBean</span><span class="params">(Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line">&lt;T&gt; T <span class="title function_">getBean</span><span class="params">(Class&lt;T&gt; requiredType, Object... args)</span> <span class="keyword">throws</span> BeansException;</span><br></pre></td></tr></table></figure>

<p>进入 <code>getBean</code> 之后进入 <code>doGetBean</code> 方法统一处理所有的 <code>getBean</code> </p>
<p>在先去单例缓存中尝试取出 <code>bean</code> 如果没有 <code>bean</code> 通过 <code>singleton</code> 和 <code>prototype</code> 判断是创建单例还是原型</p>
<ol>
<li>单例</li>
</ol>
<p><code>AbstractBeanFactory.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">	    <span class="comment">// 从单例缓存中显式删除实例：它可能已经放在那里</span></span><br><span class="line">	    <span class="comment">// 急切地通过创建过程，以允许循环引用解析。</span></span><br><span class="line">	    <span class="comment">// 还要删除任何接收到对 bean 的临时引用的 bean。</span></span><br><span class="line">	    destroySingleton(beanName);</span><br><span class="line">	    <span class="keyword">throw</span> ex;</span><br><span class="line">	&#125;</span><br><span class="line">);</span><br><span class="line">beanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br></pre></td></tr></table></figure>

<p>调用 <code>createBean</code> 方法 创建 <code>bean</code> 同时注册进单例缓存中</p>
<p>调用 <code>getObjectForBeanInstance</code> 创建 <code>bean</code></p>
<ol start="2">
<li>原型</li>
</ol>
<p><code>AbstractBeanFactory.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">prototypeInstance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	beforePrototypeCreation(beanName);</span><br><span class="line">	prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">	afterPrototypeCreation(beanName);</span><br><span class="line">&#125;</span><br><span class="line">beanInstance = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br></pre></td></tr></table></figure>

<p>调用 <code>beforePrototypeCreation</code></p>
<p>调用 <code>createBean</code> 方法 创建 <code>bean</code></p>
<p>调用 <code>afterPrototypeCreation</code></p>
<p>调用 <code>getObjectForBeanInstance</code> 创建 <code>bean</code></p>
<p><small> <code>getObjectForBeanInstance</code> 这个方法 主要是获取给定 bean 实例的对象，bean 实例本身或其创建的对象（如果是 FactoryBean） </small></p>
<p>然后就是进入 <code>createBean</code> 方法之中执行 <code>doCreateBean</code> 方法加载创建类的细节</p>
<h1 id="在-doCreateBean-方法中"><a href="#在-doCreateBean-方法中" class="headerlink" title="在 doCreateBean 方法中"></a>在 <code>doCreateBean</code> 方法中</h1><ol>
<li><p>实例化 <code>bean</code> 调用 <code>createBeanInstance</code></p>
<ol>
<li>如果是通过 <code>@Bean</code> 加载 <code>bean</code> 的话，调用 <code>instantiateUsingFactoryMethod</code> 通过方法实例化</li>
<li>匹配类的构造器，通过构造器将类实例化</li>
</ol>
</li>
<li><p>填充 <code>bean</code> 中的字段</p>
<ol>
<li>填充字段的方案是由 <code>RootBeanDefinition</code> 这个包装类中的 <code>PropertyValues</code> 字段</li>
<li>主要是调用 <code>applyPropertyValues</code> 这个方法去填充字段 </li>
<li>如果使用注解的方式加载 <code>bean</code> 的话还会加载 <code>AutowiredAnnotationProcessor</code> 这样一个类，在填充的会使用其实现的一个 <code>postProcessProperties</code> 方式读取带有 <code>@Autowired</code> 的代码进行代码字段的注入</li>
</ol>
</li>
<li><p>初始化 <code>bean</code> </p>
<ol>
<li>调用 <code>Aware</code> 容器感知功能其执行的顺序是 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BeanNameAware</span><br><span class="line">BeanClassLoaderAware</span><br><span class="line">BeanFactoryAware</span><br></pre></td></tr></table></figure>
 通过这些方法可以在当前 <code>bean</code> 中后的例如: <code>bean name</code> <code>class loader</code> <code>bean factory</code> 等一些基础信息</li>
<li>调用 <code>BeanPostProcessor</code> 中的 <code>postProcessBeforeInitialization</code></li>
<li>调用用户自定义的 <code>init method</code></li>
<li>调用 <code>BeanPostProcessor</code> 中的 <code>postProcessAfterInitialization</code></li>
</ol>
</li>
<li><p>通过 <code>earlySingletonExposure</code> 解决依赖循环的问题</p>
</li>
<li><p>将该 <code>bean</code> 注册进 <code>disposable</code> 列表中</p>
</li>
</ol>
<p>返回类型</p>
<p>得到 <code>bean</code> 的整体流程结束</p>
]]></content>
      <categories>
        <category>spring</category>
        <category>ioc</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>ioc</tag>
      </tags>
  </entry>
  <entry>
    <title>读取 bean 相关源码学习</title>
    <url>/2022/07/14/%E8%AF%BB%E5%8F%96%20bean%20%E7%9B%B8%E5%85%B3%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="读取-bean-的过程"><a href="#读取-bean-的过程" class="headerlink" title="读取 bean 的过程"></a>读取 <code>bean</code> 的过程</h1><p>创建对象 <code>ClassPathXmlApplicationContext</code></p>
<p>通过 <code>refresh</code> 进行加载</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StartupStep</span> <span class="variable">contextRefresh</span> <span class="operator">=</span> <span class="built_in">this</span>.applicationStartup.start(<span class="string">&quot;spring.context.refresh&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 准备此上下文以进行刷新。</span></span><br><span class="line">prepareRefresh();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 告诉子类刷新内部 bean 工厂。</span></span><br><span class="line"><span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 准备 bean 工厂以在此上下文中使用。</span></span><br><span class="line">prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="comment">// 允许在上下文子类中对 bean 工厂进行后处理。</span></span><br><span class="line">	postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">	<span class="type">StartupStep</span> <span class="variable">beanPostProcess</span> <span class="operator">=</span> <span class="built_in">this</span>.applicationStartup.start(<span class="string">&quot;spring.context.beans.post-process&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 调用在上下文中注册为 bean 的工厂处理器。</span></span><br><span class="line">	invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 注册拦截 bean 创建的 bean 处理器。</span></span><br><span class="line">	registerBeanPostProcessors(beanFactory);</span><br><span class="line">	beanPostProcess.end();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 为此上下文初始化消息源。</span></span><br><span class="line">	initMessageSource();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 为此上下文初始化事件多播器。</span></span><br><span class="line">	initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化特定上下文子类中的其他特殊 bean。</span></span><br><span class="line">	onRefresh();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 检查侦听器 bean 并注册它们。</span></span><br><span class="line">	registerListeners();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 实例化所有剩余的（非惰性初始化）单例。</span></span><br><span class="line">	finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 最后一步：发布相应的事件。</span></span><br><span class="line">	finishRefresh();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">	<span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">		logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> + <span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 销毁已经创建的单例以避免悬空资源。</span></span><br><span class="line">	destroyBeans();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重置&#x27;活动&#x27;标志。</span></span><br><span class="line">	cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将异常传播给调用者。</span></span><br><span class="line">	<span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 重置 Spring 核心中的常见自省缓存，因为我们 </span></span><br><span class="line">    <span class="comment">// 可能不再需要单例 bean 的元数据...</span></span><br><span class="line">    resetCommonCaches();</span><br><span class="line">	contextRefresh.end();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个方法完成了 <code>spring</code> 三种加载 <code>bean</code> 的方法</p>
<ul>
<li>通过 <code>xml</code> 加载</li>
<li>通过 <code>java</code> 方法加载</li>
<li>通过 <code>spring</code> 自动加载</li>
</ul>
<h1 id="xml-读取方案"><a href="#xml-读取方案" class="headerlink" title="xml 读取方案"></a><code>xml</code> 读取方案</h1><p>方法流程 <code>obtainFreshBeanFactory</code> -&gt; <code>refreshBeanFactory</code> -&gt; <code>loadBeanDefinitions</code> -&gt; <code>doLoadBeanDefinitions</code> -&gt; <code>registerBeanDefinitions</code> -&gt; <code>doRegisterBeanDefinitions</code></p>
<p>然后在 <code>doRegisterBeanDefinitions</code> 在这个方法中使用解析 <code>xml</code> 的方法，在读取并拼装好 <code>bean</code> 的包装类 <code>BeanDefinition</code> 注册到全局唯一的 <code>beanFactory</code> 中</p>
<h1 id="java-方法加载"><a href="#java-方法加载" class="headerlink" title="java 方法加载"></a><code>java</code> 方法加载</h1><p>其主要是通过 <code>invokeBeanFactoryPostProcessors</code> 调用 <code>invokeBeanFactoryPostProcessors</code> 在这个方法内使用 <code>invokeBeanDefinitionRegistryPostProcessors</code> 方法通过 <code>BeanDefinitionRegistryPostProcessor</code> </p>
<p>所以现在的问题又变成其中的 <code>BeanDefinitionRegistryPostProcessor</code> 是如何出现的了和 <code>xml</code> 读取方式不同是的通过 <code>java</code> 代码打注解的方式加载 <code>bean</code> 必须使用 <code>AnnotationConfigApplicationContext</code> 这个加载类启动区别在于其多了一个 <code>scan</code> 或则 <code>register</code> 方法 ( 这取决你通过使用何种方式扫描 <code>bean</code></p>
<ul>
<li><code>scan</code>: 通过 <code>java</code> 包</li>
<li><code>register</code>: 通过配置类</li>
</ul>
<p>)</p>
<p>在 <code>register</code> 中的 <code>BeanDefinitionReaderUtils</code> 使用 <code>registerBeanDefinition</code> 去注册配置 <code>bean</code> 类的包装类</p>
<p>同时在创建 <code>AnnotationConfigApplicationContext</code> 类是，其会调用一些方法去注册固定的 <code>annotation post processon</code> 去完成 <code>@bean</code> 方法的注册</p>
<p>下面就是 <code>BeanDefinitionRegistryPostProcessor</code> 中到底做了什么</p>
<p>在 <code>BeanDefinitionRegistryPostProcessor</code> 中的一个实现子类 <code>ConfigurationClassPostProcessor</code> 是其解析和加载拥有 <code>@bean</code> 方法并且注册其的包装类</p>
<p>具体是怎么是做的呢</p>
<p>在 <code>processConfigBeanDefinitions</code> 这个方法中找出所有的 <code>@Configuration</code> 配置类，然后对每个配置类进项解析</p>
<p>在方法 <code>parse</code> 中去选择以何种方式调用 <code>processConfigurationClass</code> 在 <code>retrieveBeanMethodMetadata</code> 找出有 <code>@bean</code> 的方法，将其注册到 <code>ConfigurationClass</code> 中解析完成，<code>loadBeanDefinitions</code> 这个方法正常就是将 <code>bean</code> 包装注册。</p>
<h1 id="自动加载"><a href="#自动加载" class="headerlink" title="自动加载"></a>自动加载</h1><p>其加载方式和通过 <code>@bean</code> 加载代码的方式差不多你需要在类上打上 <code>@component</code> 这个注解以便让 <code>spring</code> 中 <code>@componentScan</code> 这个注解可以加载其</p>
<p>和上面的加载方式一样进入 <code>doProcessConfigurationClass</code> 方法只不过其调用其中的 <code>componentScanParser.parse</code> 方法去扫描所有的类看其实是否拥有 <code>@component</code> 注解如果有则将其包装注册 </p>
]]></content>
      <categories>
        <category>spring</category>
        <category>ioc</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>ioc</tag>
      </tags>
  </entry>
  <entry>
    <title>aop 相关源码学习</title>
    <url>/2022/07/17/aop%20%E7%9B%B8%E5%85%B3%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="aop-相关源码学习"><a href="#aop-相关源码学习" class="headerlink" title="aop 相关源码学习"></a><code>aop</code> 相关源码学习</h1><p>从使用 <code>bean</code> 的角度出发大概看一下源码</p>
<p><code>AbstractAutowireCapableBeanFactory</code> 中的初始化 <code>bean</code> 的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">wrappedBean</span> <span class="operator">=</span> bean;</span><br><span class="line"><span class="keyword">if</span> (mbd == <span class="literal">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">	wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>((mbd != <span class="literal">null</span> ? mbd.getResourceDescription() : <span class="literal">null</span>), beanName, <span class="string">&quot;Invocation of init method failed&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (mbd == <span class="literal">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">    wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中的 <code>applyBeanPostProcessorsAfterInitialization</code> 是 <code>aop</code> 加载的主要方法</p>
<p>在该方法中回去调用每个被注册在 <code>postProcessAfterInitialization</code> 而如果你是使用了 <code>aop</code> 则会注册一个 <code>AbstractAutoProxyCreator</code> 这一个类去装配 <code>aop</code></p>
<p>这个类重写的 <code>postProcessAfterInitialization</code> 如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(<span class="meta">@Nullable</span> Object bean, String beanName)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (bean != <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="type">Object</span> <span class="variable">cacheKey</span> <span class="operator">=</span> getCacheKey(bean.getClass(), beanName);</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.earlyProxyReferences.remove(cacheKey) != bean) &#123;</span><br><span class="line">			<span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中的 <code>wrapIfNecessary</code> 就是在必要时刻为 <code>bean</code> 创建代理</p>
<p>方法中有方法 <code>getAdvicesAndAdvisorsForBean</code> 以判断是否有必要为 <code>bean</code> 创建代理如果有需要则会调用 <code>createProxy</code> 方法创建代理</p>
<p><code>craeteProxy</code> 则对需要被代理 <code>bean</code> 经行包装成 <code>ProxyFactory</code> 类并且调用 <code>getProxy</code> 这个方法而其有两种代理的方式 <code>JDK</code> 和 <code>CGLIB</code> 两种代理方式</p>
<ol>
<li><code>JDK</code> 代理方式</li>
</ol>
<p>直接使用 <code>JDK</code> 的动态代理方式</p>
<p>主要是为了接口而是用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> Proxy.newProxyInstance(classLoader, <span class="built_in">this</span>.proxiedInterfaces, <span class="built_in">this</span>);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>CGLIB</code> 代理方式</li>
</ol>
<p>其实和 <code>JDK</code> 代理方式大同小异</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getProxy</span><span class="params">(<span class="meta">@Nullable</span> ClassLoader classLoader)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">		logger.trace(<span class="string">&quot;Creating CGLIB proxy: &quot;</span> + <span class="built_in">this</span>.advised.getTargetSource());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		Class&lt;?&gt; rootClass = <span class="built_in">this</span>.advised.getTargetClass();</span><br><span class="line">			Assert.state(rootClass != <span class="literal">null</span>, <span class="string">&quot;Target class must be available for creating a CGLIB proxy&quot;</span>);</span><br><span class="line"></span><br><span class="line">		Class&lt;?&gt; proxySuperClass = rootClass;</span><br><span class="line">		<span class="keyword">if</span> (rootClass.getName().contains(ClassUtils.CGLIB_CLASS_SEPARATOR)) &#123;</span><br><span class="line">			proxySuperClass = rootClass.getSuperclass();</span><br><span class="line">			Class&lt;?&gt;[] additionalInterfaces = rootClass.getInterfaces();</span><br><span class="line">			<span class="keyword">for</span> (Class&lt;?&gt; additionalInterface : additionalInterfaces) &#123;</span><br><span class="line">				<span class="built_in">this</span>.advised.addInterface(additionalInterface);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Validate the class, writing log messages as necessary.</span></span><br><span class="line">		validateClassIfNecessary(proxySuperClass, classLoader);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Configure CGLIB Enhancer...</span></span><br><span class="line">		<span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> createEnhancer();</span><br><span class="line">		<span class="keyword">if</span> (classLoader != <span class="literal">null</span>) &#123;</span><br><span class="line">			enhancer.setClassLoader(classLoader);</span><br><span class="line">			<span class="keyword">if</span> (classLoader <span class="keyword">instanceof</span> SmartClassLoader &amp;&amp;</span><br><span class="line">					((SmartClassLoader) classLoader).isClassReloadable(proxySuperClass)) &#123;</span><br><span class="line">				enhancer.setUseCache(<span class="literal">false</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		enhancer.setSuperclass(proxySuperClass);</span><br><span class="line">		enhancer.setInterfaces(AopProxyUtils.completeProxiedInterfaces(<span class="built_in">this</span>.advised));</span><br><span class="line">		enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);</span><br><span class="line">		enhancer.setStrategy(<span class="keyword">new</span> <span class="title class_">ClassLoaderAwareGeneratorStrategy</span>(classLoader));</span><br><span class="line"></span><br><span class="line">		Callback[] callbacks = getCallbacks(rootClass);</span><br><span class="line">		Class&lt;?&gt;[] types = <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[callbacks.length];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>; x &lt; types.length; x++) &#123;</span><br><span class="line">			types[x] = callbacks[x].getClass();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// fixedInterceptorMap only populated at this point, after getCallbacks call above</span></span><br><span class="line">		enhancer.setCallbackFilter(<span class="keyword">new</span> <span class="title class_">ProxyCallbackFilter</span>(</span><br><span class="line">				<span class="built_in">this</span>.advised.getConfigurationOnlyCopy(), <span class="built_in">this</span>.fixedInterceptorMap, <span class="built_in">this</span>.fixedInterceptorOffset));</span><br><span class="line">		enhancer.setCallbackTypes(types);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Generate the proxy class and create a proxy instance.</span></span><br><span class="line">		<span class="keyword">return</span> createProxyClassAndInstance(enhancer, callbacks);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (CodeGenerationException | IllegalArgumentException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AopConfigException</span>(<span class="string">&quot;Could not generate CGLIB subclass of &quot;</span> + <span class="built_in">this</span>.advised.getTargetClass() +</span><br><span class="line">				<span class="string">&quot;: Common causes of this problem include using a final class or a non-visible class&quot;</span>,</span><br><span class="line">				ex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">		<span class="comment">// TargetSource.getTarget() failed</span></span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AopConfigException</span>(<span class="string">&quot;Unexpected AOP exception&quot;</span>, ex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就是看一下 <code>CGLIB</code> 中是如何在代理中调用 <code>bean</code> 方法的其实通过一个名叫 <code>getCallbacks</code> 来得到有的代理方案</p>
<p>在 <code>callbacks</code> 这个数组中重要的是 <code>DynamicAdvisedInterceptor</code> 这个实现他会在调用方式时进行拦截 <code>CglibMethodInvocation</code> 创建这个类并且调用 <code>proceed</code> 方法通过责任链设计模式不断调用执行这个 <code>InterceptorAndDynamicMethodMatcher</code> 数组中的内容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.currentInterceptorIndex == <span class="built_in">this</span>.interceptorsAndDynamicMethodMatchers.size() - <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> invokeJoinpoint();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而这段代码则是确定了调用目标类的方法在中间使用</p>
<p>现在可以下一个定义就是 <code>aop</code> 是通过动态来实现这个事的</p>
<p>但是问题又来了 <code>interceptorsAndDynamicMethodMatchers</code> 是如何加载出来的</p>
<p>其是通过</p>
<p><code>AdvisorChainFactory</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AdvisorChainFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Determine a list of &#123;<span class="doctag">@link</span> org.aopalliance.intercept.MethodInterceptor&#125; objects</span></span><br><span class="line"><span class="comment">	 * for the given advisor chain configuration.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> config the AOP configuration in the form of an Advised object</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> method the proxied method</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> targetClass the target class (may be &#123;<span class="doctag">@code</span> null&#125; to indicate a proxy without</span></span><br><span class="line"><span class="comment">	 * target object, in which case the method&#x27;s declaring class is the next best option)</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> a List of MethodInterceptors (may also include InterceptorAndDynamicMethodMatchers)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	List&lt;Object&gt; <span class="title function_">getInterceptorsAndDynamicInterceptionAdvice</span><span class="params">(Advised config, Method method, <span class="meta">@Nullable</span> Class&lt;?&gt; targetClass)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>中的方法加载出来的</p>
<p>他会在里面加载所有的的 <code>advisor</code> 筛选出所有合适的加入数组进行使用</p>
<p>那么 <code>advisor</code> 又是如何被加入的呢</p>
<p>他是在之前的 <code>createProxy</code> 方法中执行如下方法链<br><code>buildAdvisors</code> -&gt; <code>getAdvicesAndAdvisorsForBean</code> -&gt; <code>findEligibleAdvisors</code></p>
<p>在这个方法中 <code>findCandidateAdvisors</code> 获得所有的 <code>bean</code> 如果其是 <code>advisor</code></p>
<p>然后在通过 <code>findAdvisorsThatCanApply</code> 去匹配 <code>advisor</code> 和目标类是否匹配</p>
]]></content>
      <categories>
        <category>spring</category>
        <category>aop</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>aop</tag>
      </tags>
  </entry>
  <entry>
    <title>spring webmvc 相关源码学习</title>
    <url>/2022/07/20/spring%20webmvc%20%E7%9B%B8%E5%85%B3%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="spring-webmvc-初始化过程"><a href="#spring-webmvc-初始化过程" class="headerlink" title="spring webmvc 初始化过程"></a><code>spring webmvc</code> 初始化过程</h1><h2 id="spring-webmvc-如何使用"><a href="#spring-webmvc-如何使用" class="headerlink" title="spring webmvc 如何使用"></a><code>spring webmvc</code> 如何使用</h2><p>首先，要导入</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">&#x27;org.springframework:spring-context:5.3.21&#x27;</span></span><br><span class="line">implementation <span class="string">&#x27;org.springframework:spring-webmvc:5.3.21&#x27;</span></span><br><span class="line">implementation <span class="string">&#x27;org.springframework:spring-web:5.3.21&#x27;</span></span><br><span class="line">compileOnly <span class="string">&#x27;javax.servlet:javax.servlet-api:4.0.0&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这样四个包</p>
<p>在<code>web.xml</code>中设置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextClass<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>org.springframework.web.context.support.AnnotationConfigWebApplicationContext<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>org.tolerate.mvc.AppConfig<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>0<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>同时新建类 <code>AppConfig</code> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.EnableWebMvc;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>spring</code> 的自动装配方案，并且开启 <code>WebMvc</code></p>
<p>同时新建类 <code>UserController</code> 打上 <code>RestController</code> 注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;你好&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后对 <code>tomcat</code> 经行启动配置 <code>spring webmvc</code> 就是启动了</p>
<h2 id="DispatcherServlet-源码学习"><a href="#DispatcherServlet-源码学习" class="headerlink" title="DispatcherServlet 源码学习"></a><code>DispatcherServlet</code> 源码学习</h2><p>首先第一点在 <code>tomcat</code> 的 <code>web.xml</code> 中如果我们给 <code>servlet</code> 设置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>0<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>则会在 <code>tomcat</code> 初始化时使用该 <code>servlet</code></p>
<p><code>DispatcherServlet</code> 其是 <code>HttpServletBean</code> 的子类而是 <code>HttpServlet</code> 的子类</p>
<p>在 <code>HttpServletBean</code> 实现了 <code>init</code> 方法</p>
<p>其方法链是 <code>init</code> -&gt; <code>initServletBean</code> -&gt; <code>initWebApplicationContext</code> -&gt; <code>configureAndRefreshWebApplicationContext</code> -&gt; <code>refresh</code> 直到 <code>refresh</code> 方法中去加载所有的 <code>bean</code> 这个在之前也是讲过的</p>
<p>但是其中有一个方法是当时没有注意到的 <code>finishBeanFactoryInitialization</code> 它会实例化剩余的所有的 <code>bean</code> 其中有一个类的初始化方法是加载映射 <code>mapping</code> 的</p>
<p>其类是 <code>RequestMappingHandlerMapping</code> 从 <code>afterPropertiesSet</code> -&gt; <code>initHandlerMethods</code> -&gt; <code>processCandidateBean</code> 到这个方法中去查看该类上是否有 <code>RestController</code> 注解如果有该注解</p>
<p>则会执行 <code>detectHandlerMethods</code> 方法在 <code>getMappingForMethod</code> 方法中选择出该类中所有的方法其拥有 <code>RequestMapping</code> 注解的方法并将其注册</p>
<p>至此 <code>spring webmvc</code> 初始化完成</p>
<h1 id="接口的请求"><a href="#接口的请求" class="headerlink" title="接口的请求"></a>接口的请求</h1><p>在 <code>FrameworkServlet</code> 中实现了所有的 <code>Servlet</code> 请求方案，同时这些请求方案都是在执行一个方法叫做 <code>processRequest</code> 来完成方法请求和映射在进行初始化之后则调用 <code>doService</code> 方法在去执行 <code>doDispatch</code></p>
<p>在 <code>doDispatch</code> 中会去 <code>handlerMappings</code> 中进行映射选择出合适的方式经行调用然后调用 <code>handle</code> 进行方法的调用同时将方法的结果放在方法 <code>processDispatchResult</code> 中处理查看放回的东西可以是 <code>ModelAndView</code>，也可以是要解析为 <code>ModelAndView</code> 的 <code>Exception</code></p>
]]></content>
      <categories>
        <category>spring</category>
        <category>webmvc</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>webmvc</tag>
      </tags>
  </entry>
</search>
